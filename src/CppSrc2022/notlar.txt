25.12.2022 Pazar Ders2

C ve Cpp arasındaki farkları inceleyeceğiz

fonksiyonlara ilişkin farklılıklar

bildrimlere ve türlere ilişkin farklılıklar

tür dönüşümlerine ilişkin farklılıklar

...


kitap tavsiyesi


cpp reference ile devam edecez


----------------------------


#include <iostream>

using namespace std;

int main()
{

    //implicit int
    //C++ invalid
    //C89 valid C99/11 invalid

    //fuu();
    //int foo();

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//imliplicit int function (gizli int - ortülü int)
//C++ invalid
//C89 valid C99/11 invalid

//fuu(int number){};


/*old style function definition
 * /*old style function definition
 * C++ invalid
 * C 89valid - C99/11 invalid
 */
 */
func(x, y, z)
{

}

int main()
{

    //implicit int
    //C++ invalid
    //C89 valid C99/11 invalid

    //fuu();
    //int foo();

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//C++ bu iki fonksiyon benim için aynıdır parametreleri yoktur
void func(); //C, parametreler hakkında herhangi bilgim yok
void fuu(void); // C, parametrelerim yok

int main()
{

    func(1, 2, 3, 5);
    fuu(5, 4);


    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{

    //implicit int
    //C89 valid C99/11 invalid
    //C++ invalid
    const a = 23;
    static b = 2;

    //const int a = 23;
    //static int b = 2;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//C(C89) bool tür yok. C de bool türü yerine int türü kullanılır
//C99 _Bool tür eklenmiştir.


/*
 * C++ bool türüne sahip
 * C++ bool anahtar sözcüğü
 * C++ true, false constant
 */

int main()
{

    //logic karsılastırma dondurdugu degerın turu bool türünden Cpp
    //C de ise bu int türden
    if(15 > 25)
        ;

    cout << "\n" << "size : " << sizeof (bool) << "\n\n";



    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


//C(C89) bool tür yok. C de bool türü yerine int türü kullanılır
//C99 _Bool tür eklenmiştir.


/*
 * C++ bool türüne sahip
 * C++ bool anahtar sözcüğü
 * C++ true, false constant
 */

int main()
{

    double y = 2.5;
    int x;
    x = 4;
    bool flag = y; //otomatik olarka convertion var
                    //0 false
                    // sıfır dısı degerler true
    cout << "flag : " << flag << "\n";

    int z = flag; // false 0  true 1
    cout << "z : " << z << "\n";



    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{


    //nullptr --> bool false
    int x = 4;
    int *ptr = &x;
    bool flagPtr = ptr;
    cout << "flagPtr : " << ptr << "\n";


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //character constants
    //C++ char type
    //C int type

    printf("size: %zu\n", sizeof ('A'));


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //string literals
    //C++ const char *
    //C char *
    const char *pstr = "orhan";


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{

    //C de auto keyword vardı fakat artık depracated, otomatik ömür anlamına geliyordu
    //Automatic life
    //C++ analmı değişti, type deduction olarak.
    auto x = 10;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //C de valid
    //C++ de invalid
    for (int i = 0; i < 10; i++) {
        int i = 15;
        printf("i : 15\n", i);
    }


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //const keyword
    //C++ da invalid
    //C de gecerli her ikiside
    const int y = 10; //C++ da valid
    const int x;//C++ da invalid


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //const expression

    //a- global değişkenlere ilk deger veren ifadeler
    //b- dizi boyutu gösteren ifadeler (variable lenght array harici)
    //c- switch deyiminde case label ifadesi
    //d- yapılar bit alanı göstereni kaç bir oldugunu gosteren ifade
    //e- Dizilere ilk deger veren ifadeler

    int a = 5;
    const int b = 6;

    switch (a) {
        case b: break;
    }


    struct Data {
        int y : b;
        int z : a; //invalid
    };


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

//Linkage
/*
 * C de
 *
 * static int x = 10;  //internal link C
 * int x = 10;  //external link C
 * const int x = 10; //external link C
 *
 * C++
 *
 * int x = 10; //external link C++
 * const int x = 10; //internal link C++
 *
 * extern const int x = 10;
 *
 */

int main()
{


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

/*
 * struct Enum Union
 */

//structın ismi Data'dır C++
//struct tag dir C de
//C++ da isimleri dogrudan kullanaibliriz
//C de ise dogrudan kullanamayız

struct Data{
    int x;
    int y;
};

union Word{
    int x;
    char str[4];
};

enum Color{
    White,
    Yellow,
};

int main()
{
    Data myData;
    Word word;
    Color myColor;

    return 0;
}


/***************************************************/
/***************************************************/



//C++da struct tanımlamada isim olarak kabul edildiği için
//aynı isimde typedef tanımlar isek isim cakısması hatası alırız
struct Data{
    int x;
    int y;
};

typedef struct myData{

}Data;


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

/*
 * struct Enum Union
 */


//C de yapıların en az bir elemanı olmak zorundadır
//C++ da bu gecerli ve yapıların elemansız olarka kullanımı
struct Empty{


int main()
{


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


/*
 * User define type enumlar da tur donusumlere ilişkin farklılıklar
 *
 * C derleyicisi enum türleri int türü olarak ele alır
 * C++ derleyicisi ise enum türlerini int türü almak zorunda değil
 *
 */

/*
 * Asil farklılıklar ise modern C++
 *
 * C de enum türleri diger türlere otomatik tur donusumu var
 * C++ da sentaks hatasıdır
 *
 */


enum Color{White, Gray, Black};
enum Pos{Off, On};

int main()
{
    enum Color myColor = Black;

    //C++ da sentask hatsı
    //C de gecerli
    //myColor = 3;
    //myColor = 5.6;

    //Fakat C++ da enumların diger türlere otomatik tur donusumu vardır.
    int ival = myColor;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    /*
     * C++ da char dizilere atanan ilk deger string literalleri dizi boyutundan buyuk olamaz
     * C bu durum legaldir ve sadece uyarı mesajı verir. Fakat run time aşamasında hata verir
     * undefined behavivor
     *
     */

    char str[4] = "orhan";


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar


    /*
     * C de aritmatik turlerle pointer turleri arasında tur donusumu vardır
     * C++ da sentaks hatasıdır
     *
     */

    int x = 5;
    int *ptr = x;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar


    /*
     * C de aritmatik turlerle pointer turleri arasında tur donusumu vardır
     * C++ da sentaks hatasıdır
     *
     */

    int x = 5;
    int *ptr = x;

    /*
     * C de pointer turlerden aritmatik turlere tur donusumu vardır
     * C++ da sentaks hatası
     */

    int *ptr2;
    int ival = ptr2;


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar

      //C de legal
      //C++ de sentaks hatası
      int *pPtr = 0xB08000;
      int intP = 0xB08000;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Farklı adres turleri arasındaki donusumler

    //2 istisna dısındakileri birbirine donusturmeyin
    //istisna char * nesne adresi ve void * nesne adresi


    //C de yanlıs ama sentaks hatası değil
    //C++ da sentaks hatası
      int x = 10;
      double dPtr = &x;



    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Farklı adres turleri arasındaki donusumler

    //2 istisna dısındakileri birbirine donusturmeyin
    //istisna char * nesne adresi ve void * nesne adresi


    //C de yanlıs ama sentaks hatası değil
    //C++ da sentaks hatası
      int x = 10;
      double dPtr = &x;

   //T ve U turler olmak uzere
   //T* <--> U* turler arasında tur donusumu yok C++
   //Aynı turler arasında tur donusumu var

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Const adres donusumleri

    //T*            int *
    //const T*      const int *


    int x = 10;
    //&x; int *   T* turudur

    int a[] = {0};
    //a --> int *   T* turudur


    const int cx = 10;
    //&cx  const int * turudur


    const int primes[] = {1, 2, 3, 4};
    //&primes[0]
    //primes ---> const int *



    //C ile C++ arasinda önemli farklılık string literal

    //"orhan"   --> char[6] C de
    //"orhan"   --> const char [6]  C++ da


    //cagla  ---> const char * C++
    //cagla  ---> char *  C de

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Const adres donusumleri

    //const T*  ---> T* tur donusumu var C de
    //C++ da sentaks hatasıdır

    //T* --> const T* tur donusumu otomatik vardır C ve C++

    int x = 10;
    const int *cptr = &x; //C ve C++ kod legal
    int *ptr = cptr; //C de legal , C++ da sentaks hatası



    return 0;
}


/***************************************************/
/***************************************************/

Hatırlatmat konusu

//bunların hepsi sentaks hatası demektir
syntax error
invalid code
ill-formed code
illegal code



//bu kod hatali degil ama yanlıs kod
wrong code
int x = 10;
if(x = 10)
   ;


bad code
işini yapan kod ama boyle değilde söyle yap gibi


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //const T* turunde string literallere dikkat



    //dikkat string literallerine

    //string literalleri degistirlemez

    //char *

    char *cPtr = "orhan";
    *cPtr = 'S'; //undifened behaiovar // bu dogru demek degil

    const char *Cptr1 = "ozturk";
    *Cptr1 = "S"; //C de granti altina alırız hatayi

    //C++ da iki kullanımda sentask hatası

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //T*  --> void * istedimiz turden atama yapabiliriz

    //Bu atamaların hi birinde yanlıslık yok C de C++ da gecerli

    int x = 10;
    unsigned long y = 12;
    double dval = 5;
    char str[] = "orhan";
    void *vptr = &x;
    vptr = &y;
    vptr = &dval;
    vptr = str;

    //void * ---> T* donusum C de gecerli C++ sentaks hatası
    int z = 10;
    void *vptr1 = &z;
    int *iptr = vptr1;

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    //void * ---> T* donusum C de gecerli C++ sentaks hatası

    size_t n;

    int *pd = malloc(n * sizeof (int));
    //int *pd = (int *)malloc(n * sizeof (int));

    return 0;
}


/***************************************************/
/***************************************************/
31.12.2022 Cumartesi 3.Ders

#include <iostream>

using namespace std;

//#define      NULL       (void *)0

struct Data{

};

int main()
{
    //artık C++ da null olarak nullptr kullanacaz
    //C++11 ile dile eklendi
   int *ptr = nullptr;


   //NULL pointer nedir?
   //NULL pointer bir macrodur

   int *ptr1 = NULL;


   //C de NULL pointer yerine
   int *p = 0;
   //Derleyici 0 degerini NULL pointer'a donusturuyor


   //Otomatik (implicit) pointer convertion (array decay)
   /*
    * 1- array to pointer convetion
    * 2- function pointer convertion
    * 3- NULL pointer convertion
    */


   //0 ve NULL pointer bazı dezavantajları var
   //C++11 ile nullptr
   //nullptr bir adress sabiti
   //nullptr_t türüdür

   int *ip = nullptr;
   double *dp = nullptr;
   Data *data = nullptr;


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    //Initialization - ilk deger verme

    //C de tek bir yontem var, ilk deger verme sentaksında
    //C++ da ise bir çok yöntem mevcut

    /*
     * ilk deger verme C de
     * T x = expr;
     */

    //C++ da, Bu copy initialization dır

    /*
    int x = 10;
    double dval = 11.2;
    */



    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//C ve C++ da bu kural aynı gecerli


int a; //0 sıfır degeri ile hayata geliyorlar

int main()
{
    //Initialization - ilk deger verme


    int a; //çöp deger var

    static int y; //0 degeri ile geliyor


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Initialization - ilk deger verme

    int x; //default initialization

    //zero initialization
    /*
     * aritmatik türden değişkenlerin degeri 0
     * bool turden degişkenlerin degeri false
     * pointer değişkenlerin degeri nullptr olacak
     */

    //Global degişkenler için gecerli
    //static anahtar için gecerli

    int y;//default initialization

    int *p; //indertermined value

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10; //copy initialization

    //C++ eskide ve yenide gecerli
    int y(10); //direct initialization


    //modern C++11 deyeni gelen bir atama
    //neye ilk deger  verirsen ver {} kullanılabilir


    int z{10}; //uniform initialization  C++11
                //brace initialization


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
   //C++ da 3 tur ilk deger verme yontemi var
    int x = 10; //sadece C de var
    int y(10); //direct initialization //C++ eski ve yinede var
    int z{10}; //brace initialization C++11 var
    int t{};

    //{}  ilk deger verme yontemi en cok kullanım hale geldi


    //Neden bu ilk deger verme metodu kullnacaz

    //narrowing convertion
    double dval = 15.23;
    int x1 = dval; //gecerli ama veri kaybına neden olur
    int y1(dval);  //gecerli ve veri kaybına
    int z1{dval};  //gecerli değil

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

struct Data{

};

struct Orhn{
    Orhn(Data);
};

int main()
{
   //most vexing parse
   //scott meyers tarafından isimlendirilmiş - uydurulmus terim

    //derleyici bunu fonksiyon bilfdirimi olarak gordugu için
    //{} kullanmanız gerekli
    Orhn orhnData(Data());

    //{} ne ise yarar
    //daraltici donusum gecersiz
    //most vexing parse onler
    //uniform bir yapı sunar

    return 0;
}


/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;


int main()
{
   //{}
    //pointer diziler gecerli
    //Referanslara ilk deger verilmesin
    //Her de kullnabiliriz

    int a[]{1, 2, 3};
    int *b{a};

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

struct Data{

};

int main()
{
    //dikkat
    int x; //default initialization
    int y{}; //value initialization
    int z(); //bu function decalration -- fonksiyon tanımı

   Data mydata();


   //bunlar ilk deger verme
   int x1(10);
   int y1{20};

   /*
    * soru bu iki ifade aynı ifademi
    *
    * evet aynı ifadelerdir
    *
    * int a[] = {1, 2, 3};
    * int b[]{1, 2, 3};
    */

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int x; //default initialization
    int y{}; //degeri sıfır -- value initialization
    bool flag{}; //degeri false -- value initalization
    int *p{}; //degeri nullptr - value initialization
    int z{20}; //brace/uniform initialization


    int t(10.3); //narrowing converiton


    for (int i{}; i < 10; ++i) {
        cout << "i : "  << i << "\n";
    }

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Çıkıs Giriş işlemleri

    //cout   global değişken ismi
    //std::  namespace
    //<<  operator overloading

    std::cout << "orhan";

    //std::cin >>;

    int x = 10;

    //deryeyici bunu bir fonksiyon yapılan cagrıya donusturur
    cout << x;
    cin >> x;

    //<< ilk cagrılan global fonksyion
    //member fonksiyonu oluyor
    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Type deduction  -- tur cıkarımı


    /*
     * C de bir değişkenin türünü yazmak zorundayız
     * C++ da type deduction ile derleyici türün ne oldugunu belirler
     */

    //Type deduction için kullanılan bir cok keyword var

    //auto
    //decltype
    //template'ler


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    //int x = 10;
    auto x = 10; //deryici dekenin ilk deger veren fiadesine bakarak anlıyorum

    int ival = 10;
    auto x1 = ival; //int
    auto y1 = ival + 1.2; //double

    x1;
    y1;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <vector>
#include <cstring>

using namespace std;


double foo();


int main()
{
    //auto ile değişken tanımlarsak ilk deger vermek zorunlu


    //Soru
    //tur cıkarımı programın calısma zamanına ilişkisi varmı
    //Tamamıyle compile time da gerceklesiyor


    //AAA
    //almost always auto

    /*
     * 1
     * ilk deger vermenin zorunlu hale getirilmesi
     */
    //auto x;

      /*
       * 2 karmasık terimler basit hale getiriilir -- kodlama hatası azaltılır
       */
    //int *(*fp)(int *, int *);

    //std::vector<std:set<int,...... ///boyle gider

    //auto ile turlerını cıkartalım


    auto fp = strcmp;
    auto fp1 = &strcmp;


    int (*fp2)(const char *, const char *) = strcmp;


    /*
     * 3
     * kodun degistirilmesi fyadasi
     */

    auto x = foo();
    //Peki auto keyword zararları varmı ?

    //Soru
    //Sınıfım var, sınıfımın elemanlarını auto olmaz

    //Generic programlamada agırlıklı kullnılır
    //fonksiyonların geri donus degerinin anlasılmasında kullanılır

}


/***************************************************/
/***************************************************/

Referans Semantiği


Referans bir nesnenin yerine gecen bir isimdir



#include <iostream>

using namespace std;

int main()
{
    int x = 10;

    int *ptr = &x;

    (*ptr) = 20; // x kullnaırım- pointerda kullanım boyle


    //Bunun yerine referans semantiği kullnacaz

    /*
     * Referans semantiğinde  arka tarafta kendisi yukarıdaki işlemi ypaıyor
     * bir zararı yok
     * Generik programlamada cok iyi entegre olmus durum
     */




    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Eski C++ da refereans semantiği vardır
    //Lvalue reference -- sol  taraf referansı


    //modern C++ dile Rvalue reference eklenmiştir  -- sag taraf refereansı

    //referans dediğimiz aksini belirmediğimiz sürece aklımıza Lvalue reference gelecek


    //Referanslar için & kullanırlır

    int x = 10;
    int &r = x;

    r = 34; //x = 34;
    ++r; // ++x;

    int *p = &r; // x adresi

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Referans değişken olusturma
    //Referans değişkenini ilk deger vermeden olusturmamız mumkun değil

    //int &r; //sentaks hatası

    //Bir referans bir değişken atandıktan sonra baska bir değişkene atanamaz

    int x = 10;
    int y = 12;

    int &r1 = x;

    r1 = y; // x = y;


    //referanslar kendileri const * dır

    int *const p = &x; //top level const
    //p is a const pointer
    p = &y;


    //r2 scope alnının her yerinde x temsil eder
    int x1 = 10;
    int &r2 = x;



    return 0;

}


/***************************************************/
/***************************************************/

C de

value category
L value expresion
R value expresion

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

int main()
{
    //Eger referanalar atanan deger sag taraf degeri ise
    //const ise sentaks hatasıdır

    //int &r = 10; //sentaks hatası


    int x = 10;
    int *ptr = &x;

    int &r1 = *ptr; //  r1 x'i temsil eder


    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //hepsi x temsil
    int x = 10;
    int &r1 = x;
    int &r2(x);
    int &r3{x}; //brace

    ++r1; //++x
    ++r2; //++x
    ++r3; //++x

    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    int x = 10;
    int &r = x;

    int *p = &r; //x in adresi

    r = 20; // x = 20
    ++*p; // x = 21


    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //bir pointer referans olabilirmi

    int x = 10;
    int y = 30;

    int *p{ &x };
    int * &rp = p; //int * tur belirtir ve pointe p turu saklanır rp de


    rp = &y; // p ye y'ni adresi atandı

    *rp = 99; //  y = 99

    cout << "y : " << y << "\n";

    return 0;
}


/***************************************************/
/***************************************************/











