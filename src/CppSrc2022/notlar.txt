25.12.2022 Pazar Ders2

C ve Cpp arasındaki farkları inceleyeceğiz

fonksiyonlara ilişkin farklılıklar

bildrimlere ve türlere ilişkin farklılıklar

tür dönüşümlerine ilişkin farklılıklar

...


kitap tavsiyesi


cpp reference ile devam edecez


----------------------------


#include <iostream>

using namespace std;

int main()
{

    //implicit int
    //C++ invalid
    //C89 valid C99/11 invalid

    //fuu();
    //int foo();

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//imliplicit int function (gizli int - ortülü int)
//C++ invalid
//C89 valid C99/11 invalid

//fuu(int number){};


/*old style function definition
 * /*old style function definition
 * C++ invalid
 * C 89valid - C99/11 invalid
 */
 */
func(x, y, z)
{

}

int main()
{

    //implicit int
    //C++ invalid
    //C89 valid C99/11 invalid

    //fuu();
    //int foo();

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//C++ bu iki fonksiyon benim için aynıdır parametreleri yoktur
void func(); //C, parametreler hakkında herhangi bilgim yok
void fuu(void); // C, parametrelerim yok

int main()
{

    func(1, 2, 3, 5);
    fuu(5, 4);


    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{

    //implicit int
    //C89 valid C99/11 invalid
    //C++ invalid
    const a = 23;
    static b = 2;

    //const int a = 23;
    //static int b = 2;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//C(C89) bool tür yok. C de bool türü yerine int türü kullanılır
//C99 _Bool tür eklenmiştir.


/*
 * C++ bool türüne sahip
 * C++ bool anahtar sözcüğü
 * C++ true, false constant
 */

int main()
{

    //logic karsılastırma dondurdugu degerın turu bool türünden Cpp
    //C de ise bu int türden
    if(15 > 25)
        ;

    cout << "\n" << "size : " << sizeof (bool) << "\n\n";



    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


//C(C89) bool tür yok. C de bool türü yerine int türü kullanılır
//C99 _Bool tür eklenmiştir.


/*
 * C++ bool türüne sahip
 * C++ bool anahtar sözcüğü
 * C++ true, false constant
 */

int main()
{

    double y = 2.5;
    int x;
    x = 4;
    bool flag = y; //otomatik olarka convertion var
                    //0 false
                    // sıfır dısı degerler true
    cout << "flag : " << flag << "\n";

    int z = flag; // false 0  true 1
    cout << "z : " << z << "\n";



    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{


    //nullptr --> bool false
    int x = 4;
    int *ptr = &x;
    bool flagPtr = ptr;
    cout << "flagPtr : " << ptr << "\n";


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //character constants
    //C++ char type
    //C int type

    printf("size: %zu\n", sizeof ('A'));


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //string literals
    //C++ const char *
    //C char *
    const char *pstr = "orhan";


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{

    //C de auto keyword vardı fakat artık depracated, otomatik ömür anlamına geliyordu
    //Automatic life
    //C++ analmı değişti, type deduction olarak.
    auto x = 10;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //C de valid
    //C++ de invalid
    for (int i = 0; i < 10; i++) {
        int i = 15;
        printf("i : 15\n", i);
    }


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //const keyword
    //C++ da invalid
    //C de gecerli her ikiside
    const int y = 10; //C++ da valid
    const int x;//C++ da invalid


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //const expression

    //a- global değişkenlere ilk deger veren ifadeler
    //b- dizi boyutu gösteren ifadeler (variable lenght array harici)
    //c- switch deyiminde case label ifadesi
    //d- yapılar bit alanı göstereni kaç bir oldugunu gosteren ifade
    //e- Dizilere ilk deger veren ifadeler

    int a = 5;
    const int b = 6;

    switch (a) {
        case b: break;
    }


    struct Data {
        int y : b;
        int z : a; //invalid
    };


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

//Linkage
/*
 * C de
 *
 * static int x = 10;  //internal link C
 * int x = 10;  //external link C
 * const int x = 10; //external link C
 *
 * C++
 *
 * int x = 10; //external link C++
 * const int x = 10; //internal link C++
 *
 * extern const int x = 10;
 *
 */

int main()
{


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

/*
 * struct Enum Union
 */

//structın ismi Data'dır C++
//struct tag dir C de
//C++ da isimleri dogrudan kullanaibliriz
//C de ise dogrudan kullanamayız

struct Data{
    int x;
    int y;
};

union Word{
    int x;
    char str[4];
};

enum Color{
    White,
    Yellow,
};

int main()
{
    Data myData;
    Word word;
    Color myColor;

    return 0;
}


/***************************************************/
/***************************************************/



//C++da struct tanımlamada isim olarak kabul edildiği için
//aynı isimde typedef tanımlar isek isim cakısması hatası alırız
struct Data{
    int x;
    int y;
};

typedef struct myData{

}Data;


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

/*
 * struct Enum Union
 */


//C de yapıların en az bir elemanı olmak zorundadır
//C++ da bu gecerli ve yapıların elemansız olarka kullanımı
struct Empty{


int main()
{


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


/*
 * User define type enumlar da tur donusumlere ilişkin farklılıklar
 *
 * C derleyicisi enum türleri int türü olarak ele alır
 * C++ derleyicisi ise enum türlerini int türü almak zorunda değil
 *
 */

/*
 * Asil farklılıklar ise modern C++
 *
 * C de enum türleri diger türlere otomatik tur donusumu var
 * C++ da sentaks hatasıdır
 *
 */


enum Color{White, Gray, Black};
enum Pos{Off, On};

int main()
{
    enum Color myColor = Black;

    //C++ da sentask hatsı
    //C de gecerli
    //myColor = 3;
    //myColor = 5.6;

    //Fakat C++ da enumların diger türlere otomatik tur donusumu vardır.
    int ival = myColor;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    /*
     * C++ da char dizilere atanan ilk deger string literalleri dizi boyutundan buyuk olamaz
     * C bu durum legaldir ve sadece uyarı mesajı verir. Fakat run time aşamasında hata verir
     * undefined behavivor
     *
     */

    char str[4] = "orhan";


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar


    /*
     * C de aritmatik turlerle pointer turleri arasında tur donusumu vardır
     * C++ da sentaks hatasıdır
     *
     */

    int x = 5;
    int *ptr = x;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar


    /*
     * C de aritmatik turlerle pointer turleri arasında tur donusumu vardır
     * C++ da sentaks hatasıdır
     *
     */

    int x = 5;
    int *ptr = x;

    /*
     * C de pointer turlerden aritmatik turlere tur donusumu vardır
     * C++ da sentaks hatası
     */

    int *ptr2;
    int ival = ptr2;


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar

      //C de legal
      //C++ de sentaks hatası
      int *pPtr = 0xB08000;
      int intP = 0xB08000;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Farklı adres turleri arasındaki donusumler

    //2 istisna dısındakileri birbirine donusturmeyin
    //istisna char * nesne adresi ve void * nesne adresi


    //C de yanlıs ama sentaks hatası değil
    //C++ da sentaks hatası
      int x = 10;
      double dPtr = &x;



    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Farklı adres turleri arasındaki donusumler

    //2 istisna dısındakileri birbirine donusturmeyin
    //istisna char * nesne adresi ve void * nesne adresi


    //C de yanlıs ama sentaks hatası değil
    //C++ da sentaks hatası
      int x = 10;
      double dPtr = &x;

   //T ve U turler olmak uzere
   //T* <--> U* turler arasında tur donusumu yok C++
   //Aynı turler arasında tur donusumu var

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Const adres donusumleri

    //T*            int *
    //const T*      const int *


    int x = 10;
    //&x; int *   T* turudur

    int a[] = {0};
    //a --> int *   T* turudur


    const int cx = 10;
    //&cx  const int * turudur


    const int primes[] = {1, 2, 3, 4};
    //&primes[0]
    //primes ---> const int *



    //C ile C++ arasinda önemli farklılık string literal

    //"orhan"   --> char[6] C de
    //"orhan"   --> const char [6]  C++ da


    //cagla  ---> const char * C++
    //cagla  ---> char *  C de

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Const adres donusumleri

    //const T*  ---> T* tur donusumu var C de
    //C++ da sentaks hatasıdır

    //T* --> const T* tur donusumu otomatik vardır C ve C++

    int x = 10;
    const int *cptr = &x; //C ve C++ kod legal
    int *ptr = cptr; //C de legal , C++ da sentaks hatası



    return 0;
}


/***************************************************/
/***************************************************/

Hatırlatmat konusu

//bunların hepsi sentaks hatası demektir
syntax error
invalid code
ill-formed code
illegal code



//bu kod hatali degil ama yanlıs kod
wrong code
int x = 10;
if(x = 10)
   ;


bad code
işini yapan kod ama boyle değilde söyle yap gibi


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //const T* turunde string literallere dikkat



    //dikkat string literallerine

    //string literalleri degistirlemez

    //char *

    char *cPtr = "orhan";
    *cPtr = 'S'; //undifened behaiovar // bu dogru demek degil

    const char *Cptr1 = "ozturk";
    *Cptr1 = "S"; //C de granti altina alırız hatayi

    //C++ da iki kullanımda sentask hatası

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //T*  --> void * istedimiz turden atama yapabiliriz

    //Bu atamaların hi birinde yanlıslık yok C de C++ da gecerli

    int x = 10;
    unsigned long y = 12;
    double dval = 5;
    char str[] = "orhan";
    void *vptr = &x;
    vptr = &y;
    vptr = &dval;
    vptr = str;

    //void * ---> T* donusum C de gecerli C++ sentaks hatası
    int z = 10;
    void *vptr1 = &z;
    int *iptr = vptr1;

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    //void * ---> T* donusum C de gecerli C++ sentaks hatası

    size_t n;

    int *pd = malloc(n * sizeof (int));
    //int *pd = (int *)malloc(n * sizeof (int));

    return 0;
}


/***************************************************/
/***************************************************/
31.12.2022 Cumartesi 3.Ders

#include <iostream>

using namespace std;

//#define      NULL       (void *)0

struct Data{

};

int main()
{
    //artık C++ da null olarak nullptr kullanacaz
    //C++11 ile dile eklendi
   int *ptr = nullptr;


   //NULL pointer nedir?
   //NULL pointer bir macrodur

   int *ptr1 = NULL;


   //C de NULL pointer yerine
   int *p = 0;
   //Derleyici 0 degerini NULL pointer'a donusturuyor


   //Otomatik (implicit) pointer convertion (array decay)
   /*
    * 1- array to pointer convetion
    * 2- function pointer convertion
    * 3- NULL pointer convertion
    */


   //0 ve NULL pointer bazı dezavantajları var
   //C++11 ile nullptr
   //nullptr bir adress sabiti
   //nullptr_t türüdür

   int *ip = nullptr;
   double *dp = nullptr;
   Data *data = nullptr;


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    //Initialization - ilk deger verme

    //C de tek bir yontem var, ilk deger verme sentaksında
    //C++ da ise bir çok yöntem mevcut

    /*
     * ilk deger verme C de
     * T x = expr;
     */

    //C++ da, Bu copy initialization dır

    /*
    int x = 10;
    double dval = 11.2;
    */



    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//C ve C++ da bu kural aynı gecerli


int a; //0 sıfır degeri ile hayata geliyorlar

int main()
{
    //Initialization - ilk deger verme


    int a; //çöp deger var

    static int y; //0 degeri ile geliyor


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Initialization - ilk deger verme

    int x; //default initialization

    //zero initialization
    /*
     * aritmatik türden değişkenlerin degeri 0
     * bool turden degişkenlerin degeri false
     * pointer değişkenlerin degeri nullptr olacak
     */

    //Global degişkenler için gecerli
    //static anahtar için gecerli

    int y;//default initialization

    int *p; //indertermined value

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10; //copy initialization

    //C++ eskide ve yenide gecerli
    int y(10); //direct initialization


    //modern C++11 deyeni gelen bir atama
    //neye ilk deger  verirsen ver {} kullanılabilir


    int z{10}; //uniform initialization  C++11
                //brace initialization


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
   //C++ da 3 tur ilk deger verme yontemi var
    int x = 10; //sadece C de var
    int y(10); //direct initialization //C++ eski ve yinede var
    int z{10}; //brace initialization C++11 var
    int t{};

    //{}  ilk deger verme yontemi en cok kullanım hale geldi


    //Neden bu ilk deger verme metodu kullnacaz

    //narrowing convertion
    double dval = 15.23;
    int x1 = dval; //gecerli ama veri kaybına neden olur
    int y1(dval);  //gecerli ve veri kaybına
    int z1{dval};  //gecerli değil

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

struct Data{

};

struct Orhn{
    Orhn(Data);
};

int main()
{
   //most vexing parse
   //scott meyers tarafından isimlendirilmiş - uydurulmus terim

    //derleyici bunu fonksiyon bilfdirimi olarak gordugu için
    //{} kullanmanız gerekli
    Orhn orhnData(Data());

    //{} ne ise yarar
    //daraltici donusum gecersiz
    //most vexing parse onler
    //uniform bir yapı sunar

    return 0;
}


/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;


int main()
{
   //{}
    //pointer diziler gecerli
    //Referanslara ilk deger verilmesin
    //Her de kullnabiliriz

    int a[]{1, 2, 3};
    int *b{a};

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

struct Data{

};

int main()
{
    //dikkat
    int x; //default initialization
    int y{}; //value initialization
    int z(); //bu function decalration -- fonksiyon tanımı

   Data mydata();


   //bunlar ilk deger verme
   int x1(10);
   int y1{20};

   /*
    * soru bu iki ifade aynı ifademi
    *
    * evet aynı ifadelerdir
    *
    * int a[] = {1, 2, 3};
    * int b[]{1, 2, 3};
    */

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int x; //default initialization
    int y{}; //degeri sıfır -- value initialization
    bool flag{}; //degeri false -- value initalization
    int *p{}; //degeri nullptr - value initialization
    int z{20}; //brace/uniform initialization


    int t(10.3); //narrowing converiton


    for (int i{}; i < 10; ++i) {
        cout << "i : "  << i << "\n";
    }

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Çıkıs Giriş işlemleri

    //cout   global değişken ismi
    //std::  namespace
    //<<  operator overloading

    std::cout << "orhan";

    //std::cin >>;

    int x = 10;

    //deryeyici bunu bir fonksiyon yapılan cagrıya donusturur
    cout << x;
    cin >> x;

    //<< ilk cagrılan global fonksyion
    //member fonksiyonu oluyor
    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Type deduction  -- tur cıkarımı


    /*
     * C de bir değişkenin türünü yazmak zorundayız
     * C++ da type deduction ile derleyici türün ne oldugunu belirler
     */

    //Type deduction için kullanılan bir cok keyword var

    //auto
    //decltype
    //template'ler


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    //int x = 10;
    auto x = 10; //deryici dekenin ilk deger veren fiadesine bakarak anlıyorum

    int ival = 10;
    auto x1 = ival; //int
    auto y1 = ival + 1.2; //double

    x1;
    y1;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <vector>
#include <cstring>

using namespace std;


double foo();


int main()
{
    //auto ile değişken tanımlarsak ilk deger vermek zorunlu


    //Soru
    //tur cıkarımı programın calısma zamanına ilişkisi varmı
    //Tamamıyle compile time da gerceklesiyor


    //AAA
    //almost always auto

    /*
     * 1
     * ilk deger vermenin zorunlu hale getirilmesi
     */
    //auto x;

      /*
       * 2 karmasık terimler basit hale getiriilir -- kodlama hatası azaltılır
       */
    //int *(*fp)(int *, int *);

    //std::vector<std:set<int,...... ///boyle gider

    //auto ile turlerını cıkartalım


    auto fp = strcmp;
    auto fp1 = &strcmp;


    int (*fp2)(const char *, const char *) = strcmp;


    /*
     * 3
     * kodun degistirilmesi fyadasi
     */

    auto x = foo();
    //Peki auto keyword zararları varmı ?

    //Soru
    //Sınıfım var, sınıfımın elemanlarını auto olmaz

    //Generic programlamada agırlıklı kullnılır
    //fonksiyonların geri donus degerinin anlasılmasında kullanılır

}


/***************************************************/
/***************************************************/

Referans Semantiği


Referans bir nesnenin yerine gecen bir isimdir



#include <iostream>

using namespace std;

int main()
{
    int x = 10;

    int *ptr = &x;

    (*ptr) = 20; // x kullnaırım- pointerda kullanım boyle


    //Bunun yerine referans semantiği kullnacaz

    /*
     * Referans semantiğinde  arka tarafta kendisi yukarıdaki işlemi ypaıyor
     * bir zararı yok
     * Generik programlamada cok iyi entegre olmus durum
     */




    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Eski C++ da refereans semantiği vardır
    //Lvalue reference -- sol  taraf referansı


    //modern C++ dile Rvalue reference eklenmiştir  -- sag taraf refereansı

    //referans dediğimiz aksini belirmediğimiz sürece aklımıza Lvalue reference gelecek


    //Referanslar için & kullanırlır

    int x = 10;
    int &r = x;

    r = 34; //x = 34;
    ++r; // ++x;

    int *p = &r; // x adresi

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Referans değişken olusturma
    //Referans değişkenini ilk deger vermeden olusturmamız mumkun değil

    //int &r; //sentaks hatası

    //Bir referans bir değişken atandıktan sonra baska bir değişkene atanamaz

    int x = 10;
    int y = 12;

    int &r1 = x;

    r1 = y; // x = y;


    //referanslar kendileri const * dır

    int *const p = &x; //top level const
    //p is a const pointer
    p = &y;


    //r2 scope alnının her yerinde x temsil eder
    int x1 = 10;
    int &r2 = x;



    return 0;

}


/***************************************************/
/***************************************************/

C de

value category
L value expresion
R value expresion

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

int main()
{
    //Eger referanalar atanan deger sag taraf degeri ise
    //const ise sentaks hatasıdır

    //int &r = 10; //sentaks hatası


    int x = 10;
    int *ptr = &x;

    int &r1 = *ptr; //  r1 x'i temsil eder


    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //hepsi x temsil
    int x = 10;
    int &r1 = x;
    int &r2(x);
    int &r3{x}; //brace

    ++r1; //++x
    ++r2; //++x
    ++r3; //++x

    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    int x = 10;
    int &r = x;

    int *p = &r; //x in adresi

    r = 20; // x = 20
    ++*p; // x = 21


    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //bir pointer referans olabilirmi

    int x = 10;
    int y = 30;

    int *p{ &x };
    int * &rp = p; //int * tur belirtir ve pointe p turu saklanır rp de


    rp = &y; // p ye y'ni adresi atandı

    *rp = 99; //  y = 99

    cout << "y : " << y << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Diziye referans alınabilir

    int a[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &a; //a nın adresini tutan pointer


    int (&ra)[5] = a; //ra demek a demek

    for (int i = 0; i < 5; ++i)
    {
        cout << ra[i] << " ";
    }

    cout << "\n";


    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

int main()
{
    //Diziye referans alınabilir

    int a[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &a; //a nın adresini tutan pointer


    int (&ra)[5] = a; //ra demek a demek

    for (int i = 0; i < 5; ++i)
    {
        cout << ra[i] << " ";
    }

    cout << "\n";


    auto &ra1 = a;

    for (int i = 0; i < 5; ++i)
    {
        cout << ra1[i] << " ";
    }

    cout << "\n";

    return 0;
}


/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;

int main()
{
    auto &x; //ilk deger vermezsek sentaks hatası
    int &r = 10; //sentaks hatası


    return 0;
}


/***************************************************/
/***************************************************/

Value


a  expression ifadesi

a + 5

x * y + c > 14;

Her ifadenin bir data type oldugu gibi
Her ifadenin bir value categoryside var


L value (left value) : Nesne gösteren ifadeler
X value (expiring value): Bir kimliği yok ama bellekte bir nesneye karşılık geliyor
PR Value (Pure R value ): İfadeinin kimliği (bellekte yeri) yok, nesneye karşılık gelmiyor

GL Value : X value ve L value dan olusur.
R value : X value ile PR valuedan olusan kumeye denir



#include <iostream>

using namespace std;

int main()
{
    int a;
    a; //Lvalue

    int *ptr = &a;
    *ptr; //Lvalue

    int da[4]{};
    da[2]; //Lvalue


    //C ve C++ arasında L value R value arasıda farklılıklar var

                  C      C++
    x++           R       R
    x--           R       R
    ++x           R       L
    --x           R       L
    a, b          R       L
 x > 0 ? y : z    R       L

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;



int main()
{
    int x = 10;

    int &r = x++; //sentaks hatası
    int &r1 = ++x; //gecerli

    int y = 34;
    int &r2 = (x, y); //gecerli

    return 0;
}


/***************************************************/
/***************************************************/

Undefined  behavior (tanımsız davranış)
unsecified behavior (belirlenmemiş davranış)
implementation defined (derleyiciye baglı davranış)


undefined behaiovar
tanımsız davranış   = programınız çöp
tanımsız davranış   = programınız başınıza belle
tanımsız davranış   = İşinizi kaybetme nedeni


const anahtar sözcüğü ile tanımlanmış değişkenleri değiştirme girişimi tanımsız davranıs

string literalleri degiştirir seniz tanımsız davranısa neden olursunuz
işsaretli tam sayınız var , taşması tanımsız davranız
otomatik nesneleri çöp değerleri ile kullanamk tanımsız davranıs
bir fonksiyonun return etmemesi tanısmız davranıs




unspecified behavior -- (belirlenmemiş davranış)

belirlenmemiş davranıs tanımsız davranıs değildir
Programın ne sekilde davranacagı derleyicinin ürettiği koda baglı
Derleyici ne sekilde davranacağı konusunda herhangi bir sekşilde dokumantasyon yapmak zorunda değil
Standart derleyicilere iki veya daha fazla secenekten kod üretme imanı veriyor



#include <iostream>

using namespace std;

int f1();
int f2();

int main()
{
    int x = 10, y = 5;

    //S1
    //derleyicinin urettiği kod true mu false mu oalaiblir
    //tamamen derleyicinin nasıl kod urettiğinie baglı
    bool flag = &x > &y;

    //S2
    //Derleyici her defasında aynı sekilde kod uretmez


    //S3 f1 mi once f2 mi once cagrılır?
    int z = f1() * 3 + f2();
    //derleyicinin urettiği koda göre f1 ve f2 önce cagırma işlemi farklılık gösterebilir





    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int g = 10;

int f1(int x, int y);

int f2()
{
    g += 5;

    return 100;
}

int f3()
{
    return g - 5;
}

int main()
{
    ///Derleyici istediği sıraya göre kod uretir
    ///hangisinin önce cagıralacagı ile ilgili bir garanti yok
    f1(f2(), f3());

    return 0;
}


/***************************************************/
/***************************************************/

implementation defined (derleyiciye bağlı davranış)

implementation ile unspecified arasında fark yok

cunku implementation unsecified'in alt kumesi

fark su dokumantasyon etmek zorunlu değil

derleyici 2 veya daha fazla secenek arasından secim yapacak
ama nasıl secim naptıgını dokumante edecek




#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    char y;
    //derleyici sign veya unsign olarak belirler ve dokumantasyon yapar


    int x = -1;
    x >> 1;
    //0 veya 1 lemi beslenecek
    //Derleyici secimine kalır ama dokumante eder

    if(x >> 1 == -1)
        cout << "dogrumudur";
    else
        cout << "yanlismdir";

    size_t sz; //bir turun es ismi
                //unsig int unsig long


    int cx;

    int32_t tcx;

    return 0;
}


/***************************************************/
/***************************************************/
refereans




#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    int x = 10;

    int *p = &x;
    int **pp = &p;
    int **&r = pp;

    ++**r;  // x in degeri artrılır



    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdint>

using namespace std;

void Swap(int *p1, int *p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}


int main()
{
    int a = 12;
    int b = 55;

    Swap(&a, &b);

    cout << "a : " << a << "\n";
    cout << "b : " << b << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


fonksiyonlara referans gecme


#include <iostream>
#include <cstdint>

using namespace std;


//referans semantigi
//call by referans
void Swap(int &r1, int &r2)
{
    int temp{r1};
    r1 = r2;
    r2 = temp;
}


int main()
{
    int a = 12;
    int b = 55;

    Swap(a, b);

    cout << "a : " << a << "\n";
    cout << "b : " << b << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdint>

using namespace std;

//soru C de func fonksiyonu call by value  yada call by referans --- call by value
//soru C++ de func fonksiyonu call by value  yada call by referans -- her ikisi ile

int func(int r)
{

}

int main()
{
    int x = 10;

    func(x);

}


/***************************************************/
/***************************************************/

C de

setter
set function
mutator
output

void func(T *ptr);


get function
getter
input
void foo(const T *ptr);





#include <iostream>
#include <cstdint>

using namespace std;

int main()
{
    int x = 10;
    int &r = x; //x degistirilir
    const int &rc = x;

    ++rc;//sentaks hatası

    ++x;



}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdint>

using namespace std;

class Myclass{

};

void setter(Myclass &r); //r yi degistirip okuyabiliriz demek
void accessor(const Myclass &r); //sadece r yi okumak amaclı

int main()
{



}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdint>

using namespace std;

void func(const int &r);
//void func(int &r);

int main()
{
    int x = 10;
    const int y = 15;

    func(x);
    func(y);


}


/***************************************************/
/***************************************************/
#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    //int &r = 10; //sentaks hatası

    int y = 10;
    const int &r1 = 10;
    const int &r2 = y;

    /*
     * int temp_object{10}
     * const int &r = temp_object;
     */

    //call by value yapmak istemeyorum maliyeti yuksek



}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    const int &r1 = 10;
    int &r2 = r1; //sentaks hatası const int & --> int &

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    int x = 10;
    int &r1 = x;
    int &r2 = r1; //r2 de x i temsil eder, referans to referans yok
    int &r3 = r2;


    ++r1;
    ++r2;
    ++r3;

    cout << "x : " << x << "\n";
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//function return pointer
int *func()
{
    static int x = 10;

    return &x;
}

//function return referans
int &foo()
{
    static int x = 10;

    return x;
}

int main()
{
    func();
    foo();


}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int g = 45;

int &foo()
{
    return g;
}

int main()
{
    foo(); //Lvalue

    foo() = 15;

    cout << "g : " << g << "\n";
    ++foo();
    cout << "g : " << g << "\n";

    int &r = foo(); //r demek g demek

    r = 1234;

    cout << "g : " << g << "\n";

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//pointer semantigi ile de hatalı durumdur
int *func()
{
    int x = 10;


    return &x;
}

//referans semantigi ile de hatalı durumdur
int &foo()
{
    int x = 10;
    //

    return x;
}

int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

struct Data{
    int x, y, z;
};

struct Data *func(struct Data *p)
{


    return p;
}


struct Data &func(struct Data &r)
{


    return r;
}


int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//ilk deger vermek referans ve pointer zorunlumu?
//referans ta ilk deger zrounlu
//pointerda zorunlu değil




int main()
{

    //pointer const olmadıgı sürece farklı farklı nesneleri gosterebilirmiyiz?
    int x = 4;
    int y = 1;

    const int * p = &x;
    p = &y;


    //referans farklı farklı nesneleri gosterebilirmiyiz?

    int &r = x;


    //pointer dizisi olurmu ?

    int b, n, m;
    int *ptr[] = {&b, &n, &m};

    int &rPtr[] = {b, n, m}; // böyle birsey yok referans array diye birsey yok



    //bir dizi hem referans hem adres olabilirmi?

    int a[10] = {0};
    int (*ap)[10] = &a;
    int (&ar)[10] = a;



}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//nullptr = hic  bir yeri gostermez adres sabiti

//T * func(); //fonksiyon basarılı olmazsa nullptr


//void foo(T* ptr) //eger bana nullptr gecersen su işlemleri yaparım demek



int main()
{

    time_t time(time_t *p); //nullptr ise sadece senden time bilgisi sitiyorum
    //gecerli zamn gecersek işler değişir


}


/***************************************************/
/***************************************************/


Auto - Referans


3 tane patern

1-
auto x = expr;

2-
auto &y = expr;

3-
auto &&z = expr; // bunu ileri ele alacagız



#include <iostream>

using namespace std;

int main()
{
    auto x = 10;
    x;

}


/***************************************************/
/***************************************************/

1-
auto x = expr;


#include <iostream>

using namespace std;

int main()
{
    int y = 10;

    auto x = y; //

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    const int y = 10;
    auto x = y; //const luk goz ardı edilir int türüyüm der x

    x = 23;//burada const olsaydı atama yapamazdık

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    int y = 10;
    int &r = y;

    auto x = r; //referanslıkta düşer x in türü int

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int y = 10;
    const int &r = y;

    auto x = r; //constluk ve & düşer x in türü int

    //int x = r;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int a[10] = {};

    auto x = a; // int *x = a; dizinin ilk ogesinin adresine donusturulecek

    //auto x = &a[0];


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int const a[10] = {};

    auto x = a; // const int *x = a; dizinin ilk ogesinin adresine donusturulecek

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    auto x = "orhan"; //const char *
    x;
    //const char * y = "orhan";

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int foo(int);

int main()
{
   auto x = foo;

   x(2); //foo(2);

   //int (*x)(int) = foo; //bununla arasında hiç bir fark yoktur

}


/***************************************************/
/***************************************************/

2
auto &x = expr;


#include <iostream>

using namespace std;


int main()
{
    //l value referans olmalı yoksa sentaks hatası
    auto &x = 10; //sentaks hatası
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int y = 10;
    auto &x = y; //int & x

    x;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int ***ptr;
    auto &x = ptr; //gecerli

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int (*fptr)(int, int);
    auto &x = fptr; //geçerli
    x;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    const int x = 10;

    auto &r = x;  //constluk düşmez

    //const int %r = x;

    r = 12; //sentaks hatası


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int a[5] = { 0 };
    auto &r = a;
    //int [5]
    //int (&r)[5] = a;

    r[2] = 23;


}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    const int a[5] = { 0 };
    auto &r = a;
    //const int [5]
    //const int (&r)[5] = a;

    r[2] = 23; //sentaks hatsı


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    auto &x = "orhan";
    //const char[6]
    //const char (&x)[6] = "orhan"

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int foo(int, int);

int main()
{
    int (*fptr)(int, int) = &foo;

    auto &rfp = foo;
    //int (&)(int, int);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    const auto y = x; //gecerli

    y = 12; //const oldugundan gecersiz

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    const auto &y = x; //gecerli

    y = 12; //const oldugundan gecersiz


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    static int x = 10;

    auto y = x; // int

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    auto &r1 = x; // int &r1
    const auto &r2 = x;

    r2;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    int *ptr = &x;


    //ikiside int *
    auto ptr1 = &x; //int *

    ptr1;

    auto *p = &x; //int *

    p;

}


/***************************************************/
/***************************************************/

Fonksiyıonların varsayılan argüman alması
default arguments




#include <iostream>

using namespace std;


void func(int x, int y, int z);

int main()
{
    func(10, 20, 30);
    func(2, 3); //sentaks hatası
    func(); //sentaks hatası
    func(1, 2, 3, 4); //sentaks hatası
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//tek isna cözüm bu suan kibilgilerimizle

void func(int x, ...);

int main()
{
    func(10, 20, 30);
    func(2, 3); //sentaks hatası
    func(2); //sentaks hatası
    func(1, 2, 3, 4); //sentaks hatası

    printf(const char *p, ...); //variadic fonksiyondu
}


/***************************************************/
/***************************************************/


n tane parametren var


default fonksiyonlar

compile time ilişkin n


#include <iostream>

using namespace std;

void func(int, int, int = 10);

int main()
{
    func(1, 2, 3); //func(1, 2, 3);
    func(1, 2); //func(1, 2, 10);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

void func(int = 30, int = 20, int = 10);


int main()
{
    func(); //func(30, 20, 10);
    func(1); //func(1, 20, 10)
    func(1, 2, 3); //func(1, 2, 3);
    func(1, 2); //func(1, 2, 10);

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

void func(int, int = 20, int); //sentaks hatası


int main()
{

}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

void func(int &r);  //Lvalue ile cagırmalıyım
void foo(const int &r); //Lvalue ve Rvalue ile cagırabiliriz
int &bar(void); //dogrudan Lvalue

int main()
{
    const int &r = 10;
    //int temp = 10;

    int x = bar();
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//fonksiyon cagırma yontemleri

//T bir türü temsil eder
void f1(T x); //call by value -- deger kopyalama
void f2(T *p); //set fonksiyonu --- nesnenin adresi ile
void f3(const T *p); //get fonksiyon -- nesnenin sadece degerini okuma

//referans karsılıkları
void f22(T &r); //call by referans
void f33(const T &r);

//fonksiyonun geri dönüşleri inceleme

const T *f5(); //adres geri doner ama salt okuma amaclı
const T &f55(); //referans geri doner salt okuma amaclı


int main()
{

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//parametrelere isim verilebilir
void func(int x, int y, int z = 30);

int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int g = 45;

void func(int x, int y, int z = g + 5);

int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

int g = 45;
int func(int x, int y);
void foo(int x = func(2, 3));

int main()
{
    foo();
    foo(14);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

int func(int x, int y = 99);
void foo(int x = func(45));

int main()
{
    foo(); //foo(func(45, 99));
    foo(14); //foo(14);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

int foo()
{
    cout << "foo cagrildi\n";
    return 1;
}

int g = foo();

int main()
{
    cout << "main cagrildi\n";
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

void func(int x = 1, int y = 2, int z = 5);

int main()
{
    func();
    func(10, 20);
    func(10, 20, 30);
    func(10);

}

void func(int x, int y, int z)
{
    cout << x << ", " << y << ", " << z << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//varsayılan arguman

int g = 23;

void func(int &r = g); //varsayılan arguman olarak referans seklinde verebiliriz

int main()
{
    int a = 4;
    func(a);
    func(); //func(g);
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

void func(int *p = nullptr); //varsayılan arguman olarak pointer seklinde verebiliriz

int main()
{
    int a = 4;
    func(&a);
    func(); //func(nullptr);

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

void func(const char *p = "orhan"); //varsayılan arguman olarak string literals seklinde verebiliriz

int main()
{
    func("ozturk");
    func(); //func("orhan");

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//varsayılan arguman

//orhan.hpp
void func(int x, int y, int z);

//fonksiyon overloading ile bunu yapabilirim
void func(int x, int y, int z = 0);


int main()
{
    func(1, 2, 3);
    func(1, 2);

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

//orhan.hpp
void func(int x, int y, int z = 0);
void func(int x, int y = 10, int z);


int main()
{
    func(1, 2, 3);
    func(1, 2); //func(1, 2, 0)
    func(1); //func(1, 10, 0);

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//varsayılan arguman

void process_date(int day, int mon, int year = -1);

//-1 ile devam ederse  sunu yaparım
//farklı bir deger gecilirse sunu yaparım

int main()
{

}



/***************************************************/
/***************************************************/


Sag taraf referansı - R value referance

R value referance  (C++11) ile eklendi


R value referance'ın dile eklenme sebepleri
1- move semantics (tasima semantiği) -- sınıflar konusunda
2- perfect forwarding (mukemmel gonderim) -- Generic programlamada



L value referans

T &r = x;

T &r = 10; //sentaks hatası



sag taraf referansı

T &&r = 10;




#include <iostream>

using namespace std;

//R value referance


int main()
{

    int &&r = 10; //ilk deger verilir

    r;

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//R value referance


int main()
{

    int &&r; //sentaks hatası -- ilk deger verilmez

    r;

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance


int main()
{
    int x = 10;

    int &&r = x; //sentaks hatası -- L value atayamayız

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance


int main()
{
    int x = 10;

    int &&r = x + 5; // + operatoru --> R value

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance


int main()
{
    int x = 10;

    int & &r = x + 5; //sentask hatası

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance

int foo();

int main()
{
    int &&r = foo(); //gecerli

}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

//R value referance

int &foo();

int main()
{
    int &&r = foo(); //sentaks hatası

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance

//mulakat sorusu



int main()
{
    int &&r = 10;
    //r R value mu L value mu
    r; //L value

    int &rf = r; //kanıt


}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance

//mulakat sorusu



int main()
{
    int &&r = 10;

    r = 20; // gecerli ama ileride anlayacaz bunun nedenini


}



/***************************************************/
/***************************************************/



Bazı operatorlerin olsutrdugu ifaleri

R value
 a > b
  x == y
  x && y
  !x

 x & y
 x++
 x--


Lvalue

 ++x
 --x
 x, y

 x > 0 ? x : y; ternary operator
 (x = 20)   lvalue
 (x = 20) = 30;



T &&r = R val
T &&r; //sentaks hatası



Auto keyword -- type deduction

auto x = expr;

auto &x = expr;

auto &&x = expr; //Sakın sakına sag taraf referansı ile karıstırmayınız

Önemli

Tur cıkarımı var ise ve işin içinde && bildirgeci kullanılmıs ise
böyle tanıtılan isimlere
forwarding referance yada universal referance denmektedir .


-----------------------------------

Type deduction' a geri donelim

decaltype (specifier)

decaltype(ifade) // bu bir türe karsılık gelir ornegin int


#include <iostream>

using namespace std;

int main()
{
    int x = 10;

    decltype (x); //int turu

    decltype(x) y = 10; // y nin turu int türünden ilk deger 10 ile geldi hayata

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int x = 10;

void func(decltype (x)); //function parameters

int main()
{

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int x = 10;

//fonksiyonun geri donusu içinde kullanılabilir
decltype (x) func(decltype (x)); //function parameters

int main()
{

}

/***************************************************/
/***************************************************/


decaltype ilişkin 2 kural seti var

1- kural seti  -- parantez içine dogrudan bir isim girilmesi

   decaltype(x)
   decaltype(x.y)
   decaltype(ptr->a)



#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int ival;
    double dval;
    Data data;

    decltype (ival) x;
    decltype (dval) y;
    decltype (data) z;
    decltype (data.mx) t; //int

    Data *p = &data;
    decltype (p->mx); //int



}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    const int cx = 10;
    decltype (cx) x = 20; //const luk auto ki gibi düşmez
    //const int x = 20;

    x = 30; //sentaks hatası

}



/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int x = 10;
    int &r = x;
    decltype (r); //int & turudur, auto daki gibi referanslık düşmez

    auto t = r; //int

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int x = 10;
    int &r = x;
    decltype (r) y; //sentaks hatası ilk deger verilmediğinden
    //int & turudur, auto daki gibi referanslık düşmez


}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int a[] = {1, 2, 3, 4};

    decltype (a) b; //int b[4], dizi pointer'a donusturulmez

}



/***************************************************/
/***************************************************/

2- kural decaltype

  decaltype(expr)  isim olmayan durumlar

  decaltype((x))  2 kural seti
  decaltype(x)  1 kural icin isim expr



decaltype(19)
decaltype(x+5)
decaltype(x++)
decaltype((y))
decaltype(*ptr)
decaltype(a[5])




#include <iostream>

using namespace std;


int main()
{
    //PR VALUE
    decltype (10) x;    //int turu
    x;
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //İFADE pr value ise

    int x = 10;
    decltype (x + 3.4) y;    //double turu

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //İFADE L value ise

    int x = 10;
    decltype (++x) y = x;    //int &
    //int &y = x
    y = 22;
    cout << "x : " << x << "\n";

}



/***************************************************/
/***************************************************/


Eğer decaltype belirtecinin operandi bir isim değil ise
isim formunda olmayan bir ifade ise bu durumda


PR value expresion deger kategorisinde ise
decaltype ile elde edilen tur T turudur

L value expresion deger kategorisinde ise
decaltype ile elde edilen tur T& turudur

X value expression deger kategorisinde ise
decaltype ile elde edilen tur T && turudur



#include <iostream>

using namespace std;


int main()
{
    int x = 10;
    int *ptr = &x;

    //L value bir expression
    decltype (*ptr) y = x;    //int &
    y = 22;
    cout << "x : " << x << "\n";

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    int a[10][20] {};

    //L value
    decltype (a[2][3]) y = x;    //int &
    y = 22;
    cout << "x : " << x << "\n";

}

/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;

int &&foo();

int main()
{

    decltype (foo()) y = 10; //int &&


}

/***************************************************/
/***************************************************/

ozet

decaltype(isim) bu değişkenin turu ne ise türü o ve const'luk ve referanslık düşmez
decaltype(isim formunda değil ise) T , T&, T&&



#include <iostream>

using namespace std;

int &&foo();

int main()
{
    int x = 10;

    decltype (x); //int

    //Lvalue
    decltype ((x)); //int &

}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;

    ++x;
    size_t y = sizeof (++x);
    //derleyici burada kod uretme
    //unevaluated contex devererye girigi için sizeof operatorunda ++x için kod üretilmez

    cout << "x = " << x << "\n";

}

/***************************************************/
/***************************************************/


decaltype da unevaluated contex olusturur



#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;

    decltype (++x) y = x;
    //unevaluated contex

    cout << "x = " << x << "\n";
}

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;

    decltype (++x) y = 10; //int & oldugunda sentask hatası
    //unevaluated contex

    cout << "x = " << x << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;
    int *ptr = nullptr;

    decltype (*ptr) y = x; //gecerli
    //burada nullptr isleme alınmaz
    //eger ele alınırsa tanımsız davranış olur

    cout << "x = " << x << "\n";
}

/***************************************************/
/***************************************************/


constexpr

C++11 ile dile aklenen anahtarsözcük

const'tan ayrı bir anahtarsözcük



#include <iostream>

using namespace std;


int main()
{
    //C++ da const anahtar sözcüğü ile olsuturulan ifade hayata ilk deger alarak gelmek zorunda
    const int x = 10;
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    //C++ da const anahtar sözcüğü ile olsuturulan ifade hayata ilk deger alarak gelmek zorunda
    const int x = 10;

    int a[x] = { 0 };

    int y = 12;

    switch (10) {
        case x: break;
    }
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    int y = 15;
    //
    //
    const int x = y + 10; //sabit ifadesi olmuyordu

    int a[x] = { 0 }; //sentaks hatası

}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int foo();

int main()
{
    const int x = foo(); //sabit ifadesi olmuyordu

    int a[x] = { 0 }; //sentaks hatası
}

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

int main()
{
    //ilk deger vermek zorunlu
    //x ifadesi salt okuma amaçlı
    constexpr int x = 10;

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    int y = 10;
    constexpr int x = y; //sentaks

    //x ilk deger veren ifadeler sabit ifadeleri olması lazım
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    constexpr int x = 10;
    constexpr int y = 20;
    constexpr int z = 30;

    (x + y + z) * 3;

    int a[(x + y + z) * 3];

}

/***************************************************/
/***************************************************/


constexpr  c++11 fonksiyon modeli


constexpr functions

öyle bir fonksiyon ki belirli koşullar altında çağrı yapıldıgında derleme zamanında (compile)
geri dönüş degeri sabit olarak elde edilecek


constexpr C++11 ile ilk geldiğinde kısıltlamalı haldeydi
constexpr functions oneliner olmak zorundaydı, yani sadece returnden olusan fonksiyonlardı

constexpr int func(int x)
{
   return x *10;
}


C++14 ve C++17 ile böyle koşullar kalktı


#include <iostream>

using namespace std;


//sonuc ürettiği zaman compile time da
//onliner bir fonksiyon
constexpr int square(int a)
{
    return a * a;
}

int main()
{


}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//sonuc ürettiği zaman compile time da
//onliner bir fonksiyon
constexpr int square(int a)
{
    return a * a;
}

constexpr int ndigit(int ival)
{
    if(ival == 0)
        return 1;

    int digit_count = 0;

    while (ival) {
        ++digit_count;
        ival /= 10;
    }

    return digit_count;
}


int main()
{
    constexpr int a = 10;
    constexpr int b = 20;

    square(a); //sabir ifade

    int arr[square(a)];

    square(a * b + 3);

    int dArr[square(a * b + 3)];


    ndigit(a * b);
    ndigit(a * b + 1200);


    ndigit(square(a * b + 3));

    int ar[ndigit(square(a * b + 3))] = { 0 };


}

/***************************************************/
/***************************************************/






















































