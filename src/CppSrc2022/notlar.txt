25.12.2022 Pazar Ders2

C ve Cpp arasındaki farkları inceleyeceğiz

fonksiyonlara ilişkin farklılıklar

bildrimlere ve türlere ilişkin farklılıklar

tür dönüşümlerine ilişkin farklılıklar

...


kitap tavsiyesi


cpp reference ile devam edecez


----------------------------


#include <iostream>

using namespace std;

int main()
{

    //implicit int
    //C++ invalid
    //C89 valid C99/11 invalid

    //fuu();
    //int foo();

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//imliplicit int function (gizli int - ortülü int)
//C++ invalid
//C89 valid C99/11 invalid

//fuu(int number){};


/*old style function definition
 * /*old style function definition
 * C++ invalid
 * C 89valid - C99/11 invalid
 */
 */
func(x, y, z)
{

}

int main()
{

    //implicit int
    //C++ invalid
    //C89 valid C99/11 invalid

    //fuu();
    //int foo();

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//C++ bu iki fonksiyon benim için aynıdır parametreleri yoktur
void func(); //C, parametreler hakkında herhangi bilgim yok
void fuu(void); // C, parametrelerim yok

int main()
{

    func(1, 2, 3, 5);
    fuu(5, 4);


    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{

    //implicit int
    //C89 valid C99/11 invalid
    //C++ invalid
    const a = 23;
    static b = 2;

    //const int a = 23;
    //static int b = 2;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//C(C89) bool türü yok. C de bool türü yerine int türü kullanılır
//C99 _Bool türü eklenmiştir.


/*
 * C++ bool türüne sahip
 * C++ bool anahtar sözcüğü
 * C++ true, false constant
 */

int main()
{

    //logic karsılastırma dondurdugu degerın turu bool türünden Cpp
    //C de ise bu int türden
    if(15 > 25)
        ;

    cout << "\n" << "size : " << sizeof (bool) << "\n\n";



    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


//C(C89) bool tür yok. C de bool türü yerine int türü kullanılır
//C99 _Bool tür eklenmiştir.


/*
 * C++ bool türüne sahip
 * C++ bool anahtar sözcüğü
 * C++ true, false constant
 */

int main()
{

    double y = 2.5;
    int x;
    x = 4;
    bool flag = y; //otomatik olarka convertion var
                    //0 false
                    // sıfır dısı degerler true
    cout << "flag : " << flag << "\n";

    int z = flag; // false 0  true 1
    cout << "z : " << z << "\n";



    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{


    //nullptr --> bool false
    int x = 4;
    int *ptr = &x;
    bool flagPtr = ptr;
    cout << "flagPtr : " << ptr << "\n";


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //character constants
    //C++ char type
    //C int type

    printf("size: %zu\n", sizeof ('A'));


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //string literals
    //C++ const char *
    //C char *
    const char *pstr = "orhan";


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{

    //C de auto keyword vardı fakat artık depracated, otomatik ömür anlamına geliyordu
    //Automatic life
    //C++ analmı değişti, type deduction olarak.
    auto x = 10;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //C de valid
    //C++ de invalid
    for (int i = 0; i < 10; i++) {
        int i = 15;
        printf("i : 15\n", i);
    }


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //const keyword
    //C++ da invalid
    //C de gecerli her ikiside
    const int y = 10; //C++ da valid
    const int x;//C++ da invalid


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{

    //const expression

    //a- global değişkenlere ilk deger veren ifadeler
    //b- dizi boyutu gösteren ifadeler (variable lenght array harici)
    //c- switch deyiminde case label ifadesi
    //d- yapılar bit alanı göstereni kaç bir oldugunu gosteren ifade
    //e- Dizilere ilk deger veren ifadeler

    int a = 5;
    const int b = 6;

    switch (a) {
        case b: break;
    }


    struct Data {
        int y : b;
        int z : a; //invalid
    };


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

//Linkage
/*
 * C de
 *
 * static int x = 10;  //internal link C
 * int x = 10;  //external link C
 * const int x = 10; //external link C
 *
 * C++
 *
 * int x = 10; //external link C++
 * const int x = 10; //internal link C++
 *
 * extern const int x = 10;
 *
 */

int main()
{


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

/*
 * struct Enum Union
 */

//structın ismi Data'dır C++
//struct tag dir C de
//C++ da isimleri dogrudan kullanaibliriz
//C de ise dogrudan kullanamayız

struct Data{
    int x;
    int y;
};

union Word{
    int x;
    char str[4];
};

enum Color{
    White,
    Yellow,
};

int main()
{
    Data myData;
    Word word;
    Color myColor;

    return 0;
}


/***************************************************/
/***************************************************/



//C++da struct tanımlamada isim olarak kabul edildiği için
//aynı isimde typedef tanımlar isek isim cakısması hatası alırız
struct Data{
    int x;
    int y;
};

typedef struct myData{

}Data;


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

/*
 * struct Enum Union
 */


//C de yapıların en az bir elemanı olmak zorundadır
//C++ da bu gecerli ve yapıların elemansız olarka kullanımı
struct Empty{


int main()
{


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


/*
 * User define type enumlar da tur donusumlere ilişkin farklılıklar
 *
 * C derleyicisi enum türleri int türü olarak ele alır
 * C++ derleyicisi ise enum türlerini int türü almak zorunda değil
 *
 */

/*
 * Asil farklılıklar ise modern C++
 *
 * C de enum türleri diger türlere otomatik tur donusumu var
 * C++ da sentaks hatasıdır
 *
 */


enum Color{White, Gray, Black};
enum Pos{Off, On};

int main()
{
    enum Color myColor = Black;

    //C++ da sentask hatsı
    //C de gecerli
    //myColor = 3;
    //myColor = 5.6;

    //Fakat C++ da enumların diger türlere otomatik tur donusumu vardır.
    int ival = myColor;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    /*
     * C++ da char dizilere atanan ilk deger string literalleri dizi boyutundan buyuk olamaz
     * C bu durum legaldir ve sadece uyarı mesajı verir. Fakat run time aşamasında hata verir
     * undefined behavivor
     *
     */

    char str[4] = "orhan";


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar


    /*
     * C de aritmatik turlerle pointer turleri arasında tur donusumu vardır
     * C++ da sentaks hatasıdır
     *
     */

    int x = 5;
    int *ptr = x;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar


    /*
     * C de aritmatik turlerle pointer turleri arasında tur donusumu vardır
     * C++ da sentaks hatasıdır
     *
     */

    int x = 5;
    int *ptr = x;

    /*
     * C de pointer turlerden aritmatik turlere tur donusumu vardır
     * C++ da sentaks hatası
     */

    int *ptr2;
    int ival = ptr2;


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Tur donusumlere ilişkin farklılıklar

      //C de legal
      //C++ de sentaks hatası
      int *pPtr = 0xB08000;
      int intP = 0xB08000;


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Farklı adres turleri arasındaki donusumler

    //2 istisna dısındakileri birbirine donusturmeyin
    //istisna char * nesne adresi ve void * nesne adresi


    //C de yanlıs ama sentaks hatası değil
    //C++ da sentaks hatası
      int x = 10;
      double dPtr = &x;



    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Farklı adres turleri arasındaki donusumler

    //2 istisna dısındakileri birbirine donusturmeyin
    //istisna char * nesne adresi ve void * nesne adresi


    //C de yanlıs ama sentaks hatası değil
    //C++ da sentaks hatası
      int x = 10;
      double dPtr = &x;

   //T ve U turler olmak uzere
   //T* <--> U* turler arasında tur donusumu yok C++
   //Aynı turler arasında tur donusumu var

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Const adres donusumleri

    //T*            int *
    //const T*      const int *


    int x = 10;
    //&x; int *   T* turudur

    int a[] = {0};
    //a --> int *   T* turudur


    const int cx = 10;
    //&cx  const int * turudur


    const int primes[] = {1, 2, 3, 4};
    //&primes[0]
    //primes ---> const int *



    //C ile C++ arasinda önemli farklılık string literal

    //"orhan"   --> char[6] C de
    //"orhan"   --> const char [6]  C++ da


    //cagla  ---> const char * C++
    //cagla  ---> char *  C de

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


int main()
{
    //Const adres donusumleri

    //const T*  ---> T* tur donusumu var C de
    //C++ da sentaks hatasıdır

    //T* --> const T* tur donusumu otomatik vardır C ve C++

    int x = 10;
    const int *cptr = &x; //C ve C++ kod legal
    int *ptr = cptr; //C de legal , C++ da sentaks hatası



    return 0;
}


/***************************************************/
/***************************************************/

Hatırlatmat konusu

//bunların hepsi sentaks hatası demektir
syntax error
invalid code
ill-formed code
illegal code



//bu kod hatali degil ama yanlıs kod
wrong code
int x = 10;
if(x = 10)
   ;


bad code
işini yapan kod ama boyle değilde söyle yap gibi


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //const T* turunde string literallere dikkat



    //dikkat string literallerine

    //string literalleri degistirlemez

    //char *

    char *cPtr = "orhan";
    *cPtr = 'S'; //undifened behaiovar // bu dogru demek degil

    const char *Cptr1 = "ozturk";
    *Cptr1 = "S"; //C de granti altina alırız hatayi

    //C++ da iki kullanımda sentask hatası

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //T*  --> void * istedimiz turden atama yapabiliriz

    //Bu atamaların hi birinde yanlıslık yok C de C++ da gecerli

    int x = 10;
    unsigned long y = 12;
    double dval = 5;
    char str[] = "orhan";
    void *vptr = &x;
    vptr = &y;
    vptr = &dval;
    vptr = str;

    //void * ---> T* donusum C de gecerli C++ sentaks hatası
    int z = 10;
    void *vptr1 = &z;
    int *iptr = vptr1;

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    //void * ---> T* donusum C de gecerli C++ sentaks hatası

    size_t n;

    int *pd = malloc(n * sizeof (int));
    //int *pd = (int *)malloc(n * sizeof (int));

    return 0;
}


/***************************************************/
/***************************************************/
31.12.2022 Cumartesi 3.Ders

#include <iostream>

using namespace std;

//#define      NULL       (void *)0

struct Data{

};

int main()
{
    //artık C++ da null olarak nullptr kullanacaz
    //C++11 ile dile eklendi
   int *ptr = nullptr;


   //NULL pointer nedir?
   //NULL pointer bir macrodur

   int *ptr1 = NULL;


   //C de NULL pointer yerine
   int *p = 0;
   //Derleyici 0 degerini NULL pointer'a donusturuyor


   //Otomatik (implicit) pointer convertion (array decay)
   /*
    * 1- array to pointer convetion
    * 2- function pointer convertion
    * 3- NULL pointer convertion
    */


   //0 ve NULL pointer bazı dezavantajları var
   //C++11 ile nullptr
   //nullptr bir adress sabiti
   //nullptr_t türüdür

   int *ip = nullptr;
   double *dp = nullptr;
   Data *data = nullptr;


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    //Initialization - ilk deger verme

    //C de tek bir yontem var, ilk deger verme sentaksında
    //C++ da ise bir çok yöntem mevcut

    /*
     * ilk deger verme C de
     * T x = expr;
     */

    //C++ da, Bu copy initialization dır

    /*
    int x = 10;
    double dval = 11.2;
    */



    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//C ve C++ da bu kural aynı gecerli


int a; //0 sıfır degeri ile hayata geliyorlar

int main()
{
    //Initialization - ilk deger verme


    int a; //çöp deger var

    static int y; //0 degeri ile geliyor


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //Initialization - ilk deger verme

    int x; //default initialization

    //zero initialization
    /*
     * aritmatik türden değişkenlerin degeri 0
     * bool turden degişkenlerin degeri false
     * pointer değişkenlerin degeri nullptr olacak
     */

    //Global degişkenler için gecerli
    //static anahtar için gecerli

    int y;//default initialization

    int *p; //indertermined value

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10; //copy initialization

    //C++ eskide ve yenide gecerli
    int y(10); //direct initialization


    //modern C++11 deyeni gelen bir atama
    //neye ilk deger  verirsen ver {} kullanılabilir


    int z{10}; //uniform initialization  C++11
                //brace initialization


    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
   //C++ da 3 tur ilk deger verme yontemi var
    int x = 10; //sadece C de var
    int y(10); //direct initialization //C++ eski ve yinede var
    int z{10}; //brace initialization C++11 var
    int t{};

    //{}  ilk deger verme yontemi en cok kullanım hale geldi


    //Neden bu ilk deger verme metodu kullnacaz

    //narrowing convertion
    double dval = 15.23;
    int x1 = dval; //gecerli ama veri kaybına neden olur
    int y1(dval);  //gecerli ve veri kaybına
    int z1{dval};  //gecerli değil

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

struct Data{

};

struct Orhn{
    Orhn(Data);
};

int main()
{
   //most vexing parse
   //scott meyers tarafından isimlendirilmiş - uydurulmus terim

    //derleyici bunu fonksiyon bilfdirimi olarak gordugu için
    //{} kullanmanız gerekli
    Orhn orhnData(Data());

    //{} ne ise yarar
    //daraltici donusum gecersiz
    //most vexing parse onler
    //uniform bir yapı sunar

    return 0;
}


/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;


int main()
{
   //{}
    //pointer diziler gecerli
    //Referanslara ilk deger verilmesin
    //Her de kullnabiliriz

    int a[]{1, 2, 3};
    int *b{a};

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

struct Data{

};

int main()
{
    //dikkat
    int x; //default initialization
    int y{}; //value initialization
    int z(); //bu function decalration -- fonksiyon tanımı

   Data mydata();


   //bunlar ilk deger verme
   int x1(10);
   int y1{20};

   /*
    * soru bu iki ifade aynı ifademi
    *
    * evet aynı ifadelerdir
    *
    * int a[] = {1, 2, 3};
    * int b[]{1, 2, 3};
    */

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int x; //default initialization
    int y{}; //degeri sıfır -- value initialization
    bool flag{}; //degeri false -- value initalization
    int *p{}; //degeri nullptr - value initialization
    int z{20}; //brace/uniform initialization


    int t(10.3); //narrowing converiton


    for (int i{}; i < 10; ++i) {
        cout << "i : "  << i << "\n";
    }

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Çıkıs Giriş işlemleri

    //cout   global değişken ismi
    //std::  namespace
    //<<  operator overloading

    std::cout << "orhan";

    //std::cin >>;

    int x = 10;

    //deryeyici bunu bir fonksiyon yapılan cagrıya donusturur
    cout << x;
    cin >> x;

    //<< ilk cagrılan global fonksyion
    //member fonksiyonu oluyor
    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Type deduction  -- tur cıkarımı


    /*
     * C de bir değişkenin türünü yazmak zorundayız
     * C++ da type deduction ile derleyici türün ne oldugunu belirler
     */

    //Type deduction için kullanılan bir cok keyword var

    //auto
    //decltype
    //template'ler


    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    //int x = 10;
    auto x = 10; //deryici dekenin ilk deger veren fiadesine bakarak anlıyorum

    int ival = 10;
    auto x1 = ival; //int
    auto y1 = ival + 1.2; //double

    x1;
    y1;

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <vector>
#include <cstring>

using namespace std;


double foo();


int main()
{
    //auto ile değişken tanımlarsak ilk deger vermek zorunlu


    //Soru
    //tur cıkarımı programın calısma zamanına ilişkisi varmı
    //Tamamıyle compile time da gerceklesiyor


    //AAA
    //almost always auto

    /*
     * 1
     * ilk deger vermenin zorunlu hale getirilmesi
     */
    //auto x;

      /*
       * 2 karmasık terimler basit hale getiriilir -- kodlama hatası azaltılır
       */
    //int *(*fp)(int *, int *);

    //std::vector<std:set<int,...... ///boyle gider

    //auto ile turlerını cıkartalım


    auto fp = strcmp;
    auto fp1 = &strcmp;


    int (*fp2)(const char *, const char *) = strcmp;


    /*
     * 3
     * kodun degistirilmesi fyadasi
     */

    auto x = foo();
    //Peki auto keyword zararları varmı ?

    //Soru
    //Sınıfım var, sınıfımın elemanlarını auto olmaz

    //Generic programlamada agırlıklı kullnılır
    //fonksiyonların geri donus degerinin anlasılmasında kullanılır

}


/***************************************************/
/***************************************************/

Referans Semantiği


Referans bir nesnenin yerine gecen bir isimdir



#include <iostream>

using namespace std;

int main()
{
    int x = 10;

    int *ptr = &x;

    (*ptr) = 20; // x kullnaırım- pointerda kullanım boyle


    //Bunun yerine referans semantiği kullnacaz

    /*
     * Referans semantiğinde  arka tarafta kendisi yukarıdaki işlemi ypaıyor
     * bir zararı yok
     * Generik programlamada cok iyi entegre olmus durum
     */




    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Eski C++ da refereans semantiği vardır
    //Lvalue reference -- sol  taraf referansı


    //modern C++ dile Rvalue reference eklenmiştir  -- sag taraf refereansı

    //referans dediğimiz aksini belirmediğimiz sürece aklımıza Lvalue reference gelecek


    //Referanslar için & kullanırlır

    int x = 10;
    int &r = x;

    r = 34; //x = 34;
    ++r; // ++x;

    int *p = &r; // x adresi

    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Referans değişken olusturma
    //Referans değişkenini ilk deger vermeden olusturmamız mumkun değil

    //int &r; //sentaks hatası

    //Bir referans bir değişken atandıktan sonra baska bir değişkene atanamaz

    int x = 10;
    int y = 12;

    int &r1 = x;

    r1 = y; // x = y;


    //referanslar kendileri const * dır

    int *const p = &x; //top level const
    //p is a const pointer
    p = &y;


    //r2 scope alnının her yerinde x temsil eder
    int x1 = 10;
    int &r2 = x;



    return 0;

}


/***************************************************/
/***************************************************/

C de

value category
L value expresion
R value expresion

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

int main()
{
    //Eger referanalar atanan deger sag taraf degeri ise
    //const ise sentaks hatasıdır

    //int &r = 10; //sentaks hatası


    int x = 10;
    int *ptr = &x;

    int &r1 = *ptr; //  r1 x'i temsil eder


    return 0;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //hepsi x temsil
    int x = 10;
    int &r1 = x;
    int &r2(x);
    int &r3{x}; //brace

    ++r1; //++x
    ++r2; //++x
    ++r3; //++x

    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int main()
{
    int x = 10;
    int &r = x;

    int *p = &r; //x in adresi

    r = 20; // x = 20
    ++*p; // x = 21


    cout << "x : " << x << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //bir pointer referans olabilirmi

    int x = 10;
    int y = 30;

    int *p{ &x };
    int * &rp = p; //int * tur belirtir ve pointe p turu saklanır rp de


    rp = &y; // p ye y'ni adresi atandı

    *rp = 99; //  y = 99

    cout << "y : " << y << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    //Diziye referans alınabilir

    int a[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &a; //a nın adresini tutan pointer


    int (&ra)[5] = a; //ra demek a demek

    for (int i = 0; i < 5; ++i)
    {
        cout << ra[i] << " ";
    }

    cout << "\n";


    return 0;
}


/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

int main()
{
    //Diziye referans alınabilir

    int a[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &a; //a nın adresini tutan pointer


    int (&ra)[5] = a; //ra demek a demek

    for (int i = 0; i < 5; ++i)
    {
        cout << ra[i] << " ";
    }

    cout << "\n";


    auto &ra1 = a;

    for (int i = 0; i < 5; ++i)
    {
        cout << ra1[i] << " ";
    }

    cout << "\n";

    return 0;
}


/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;

int main()
{
    auto &x; //ilk deger vermezsek sentaks hatası
    int &r = 10; //sentaks hatası


    return 0;
}


/***************************************************/
/***************************************************/

Value


a  expression ifadesi

a + 5

x * y + c > 14;

Her ifadenin bir data type oldugu gibi
Her ifadenin bir value categoryside var


L value (left value) : Nesne gösteren ifadeler
X value (expiring value): Bir kimliği yok ama bellekte bir nesneye karşılık geliyor
PR Value (Pure R value ): İfadeinin kimliği (bellekte yeri) yok, nesneye karşılık gelmiyor

GL Value : X value ve L value dan olusur.
R value : X value ile PR valuedan olusan kumeye denir



#include <iostream>

using namespace std;

int main()
{
    int a;
    a; //Lvalue

    int *ptr = &a;
    *ptr; //Lvalue

    int da[4]{};
    da[2]; //Lvalue


    //C ve C++ arasında L value R value arasıda farklılıklar var

                  C      C++
    x++           R       R
    x--           R       R
    ++x           R       L
    --x           R       L
    a, b          R       L
 x > 0 ? y : z    R       L

    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;



int main()
{
    int x = 10;

    int &r = x++; //sentaks hatası
    int &r1 = ++x; //gecerli

    int y = 34;
    int &r2 = (x, y); //gecerli

    return 0;
}


/***************************************************/
/***************************************************/

Undefined  behavior (tanımsız davranış)
unsecified behavior (belirlenmemiş davranış)
implementation defined (derleyiciye baglı davranış)


undefined behaiovar
tanımsız davranış   = programınız çöp
tanımsız davranış   = programınız başınıza belle
tanımsız davranış   = İşinizi kaybetme nedeni


const anahtar sözcüğü ile tanımlanmış değişkenleri değiştirme girişimi tanımsız davranıs

string literalleri degiştirir seniz tanımsız davranısa neden olursunuz
işsaretli tam sayınız var , taşması tanımsız davranız
otomatik nesneleri çöp değerleri ile kullanamk tanımsız davranıs
bir fonksiyonun return etmemesi tanısmız davranıs




unspecified behavior -- (belirlenmemiş davranış)

belirlenmemiş davranıs tanımsız davranıs değildir
Programın ne sekilde davranacagı derleyicinin ürettiği koda baglı
Derleyici ne sekilde davranacağı konusunda herhangi bir sekşilde dokumantasyon yapmak zorunda değil
Standart derleyicilere iki veya daha fazla secenekten kod üretme imanı veriyor



#include <iostream>

using namespace std;

int f1();
int f2();

int main()
{
    int x = 10, y = 5;

    //S1
    //derleyicinin urettiği kod true mu false mu oalaiblir
    //tamamen derleyicinin nasıl kod urettiğinie baglı
    bool flag = &x > &y;

    //S2
    //Derleyici her defasında aynı sekilde kod uretmez


    //S3 f1 mi once f2 mi once cagrılır?
    int z = f1() * 3 + f2();
    //derleyicinin urettiği koda göre f1 ve f2 önce cagırma işlemi farklılık gösterebilir





    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int g = 10;

int f1(int x, int y);

int f2()
{
    g += 5;

    return 100;
}

int f3()
{
    return g - 5;
}

int main()
{
    ///Derleyici istediği sıraya göre kod uretir
    ///hangisinin önce cagıralacagı ile ilgili bir garanti yok
    f1(f2(), f3());

    return 0;
}


/***************************************************/
/***************************************************/

implementation defined (derleyiciye bağlı davranış)

implementation ile unspecified arasında fark yok

cunku implementation unsecified'in alt kumesi

fark su dokumantasyon etmek zorunlu değil

derleyici 2 veya daha fazla secenek arasından secim yapacak
ama nasıl secim naptıgını dokumante edecek




#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    char y;
    //derleyici sign veya unsign olarak belirler ve dokumantasyon yapar


    int x = -1;
    x >> 1;
    //0 veya 1 lemi beslenecek
    //Derleyici secimine kalır ama dokumante eder

    if(x >> 1 == -1)
        cout << "dogrumudur";
    else
        cout << "yanlismdir";

    size_t sz; //bir turun es ismi
                //unsig int unsig long


    int cx;

    int32_t tcx;

    return 0;
}


/***************************************************/
/***************************************************/
refereans




#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    int x = 10;

    int *p = &x;
    int **pp = &p;
    int **&r = pp;

    ++**r;  // x in degeri artrılır



    return 0;
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdint>

using namespace std;

void Swap(int *p1, int *p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}


int main()
{
    int a = 12;
    int b = 55;

    Swap(&a, &b);

    cout << "a : " << a << "\n";
    cout << "b : " << b << "\n";

    return 0;
}


/***************************************************/
/***************************************************/


fonksiyonlara referans gecme


#include <iostream>
#include <cstdint>

using namespace std;


//referans semantigi
//call by referans
void Swap(int &r1, int &r2)
{
    int temp{r1};
    r1 = r2;
    r2 = temp;
}


int main()
{
    int a = 12;
    int b = 55;

    Swap(a, b);

    cout << "a : " << a << "\n";
    cout << "b : " << b << "\n";

    return 0;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdint>

using namespace std;

//soru C de func fonksiyonu call by value  yada call by referans --- call by value
//soru C++ de func fonksiyonu call by value  yada call by referans -- her ikisi ile

int func(int r)
{

}

int main()
{
    int x = 10;

    func(x);

}


/***************************************************/
/***************************************************/

C de

setter
set function
mutator
output

void func(T *ptr);


get function
getter
input
void foo(const T *ptr);





#include <iostream>
#include <cstdint>

using namespace std;

int main()
{
    int x = 10;
    int &r = x; //x degistirilir
    const int &rc = x;

    ++rc;//sentaks hatası

    ++x;



}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdint>

using namespace std;

class Myclass{

};

void setter(Myclass &r); //r yi degistirip okuyabiliriz demek
void accessor(const Myclass &r); //sadece r yi okumak amaclı

int main()
{



}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdint>

using namespace std;

void func(const int &r);
//void func(int &r);

int main()
{
    int x = 10;
    const int y = 15;

    func(x);
    func(y);


}


/***************************************************/
/***************************************************/
#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    //int &r = 10; //sentaks hatası

    int y = 10;
    const int &r1 = 10;
    const int &r2 = y;

    /*
     * int temp_object{10}
     * const int &r = temp_object;
     */

    //call by value yapmak istemeyorum maliyeti yuksek



}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    const int &r1 = 10;
    int &r2 = r1; //sentaks hatası const int & --> int &

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdint>

using namespace std;


int main()
{
    int x = 10;
    int &r1 = x;
    int &r2 = r1; //r2 de x i temsil eder, referans to referans yok
    int &r3 = r2;


    ++r1;
    ++r2;
    ++r3;

    cout << "x : " << x << "\n";
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//function return pointer
int *func()
{
    static int x = 10;

    return &x;
}

//function return referans
int &foo()
{
    static int x = 10;

    return x;
}

int main()
{
    func();
    foo();


}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

int g = 45;

int &foo()
{
    return g;
}

int main()
{
    foo(); //Lvalue

    foo() = 15;

    cout << "g : " << g << "\n";
    ++foo();
    cout << "g : " << g << "\n";

    int &r = foo(); //r demek g demek

    r = 1234;

    cout << "g : " << g << "\n";

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//pointer semantigi ile de hatalı durumdur
int *func()
{
    int x = 10;


    return &x;
}

//referans semantigi ile de hatalı durumdur
int &foo()
{
    int x = 10;
    //

    return x;
}

int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

struct Data{
    int x, y, z;
};

struct Data *func(struct Data *p)
{


    return p;
}


struct Data &func(struct Data &r)
{


    return r;
}


int main()
{


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//ilk deger vermek referans ve pointer zorunlumu?
//referans ta ilk deger zrounlu
//pointerda zorunlu değil




int main()
{

    //pointer const olmadıgı sürece farklı farklı nesneleri gosterebilirmiyiz?
    int x = 4;
    int y = 1;

    const int * p = &x;
    p = &y;


    //referans farklı farklı nesneleri gosterebilirmiyiz?

    int &r = x;


    //pointer dizisi olurmu ?

    int b, n, m;
    int *ptr[] = {&b, &n, &m};

    int &rPtr[] = {b, n, m}; // böyle birsey yok referans array diye birsey yok



    //bir dizi hem referans hem adres olabilirmi?

    int a[10] = {0};
    int (*ap)[10] = &a;
    int (&ar)[10] = a;



}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//nullptr = hic  bir yeri gostermez adres sabiti

//T * func(); //fonksiyon basarılı olmazsa nullptr


//void foo(T* ptr) //eger bana nullptr gecersen su işlemleri yaparım demek



int main()
{

    time_t time(time_t *p); //nullptr ise sadece senden time bilgisi sitiyorum
    //gecerli zamn gecersek işler değişir


}


/***************************************************/
/***************************************************/


Auto - Referans


3 tane patern

1-
auto x = expr;

2-
auto &y = expr;

3-
auto &&z = expr; // bunu ileri ele alacagız



#include <iostream>

using namespace std;

int main()
{
    auto x = 10;
    x;

}


/***************************************************/
/***************************************************/

1-
auto x = expr;


#include <iostream>

using namespace std;

int main()
{
    int y = 10;

    auto x = y; //

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    const int y = 10;
    auto x = y; //const luk goz ardı edilir int türüyüm der x

    x = 23;//burada const olsaydı atama yapamazdık

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    int y = 10;
    int &r = y;

    auto x = r; //referanslıkta düşer x in türü int

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int y = 10;
    const int &r = y;

    auto x = r; //constluk ve & düşer x in türü int

    //int x = r;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int a[10] = {};

    auto x = a; // int *x = a; dizinin ilk ogesinin adresine donusturulecek

    //auto x = &a[0];


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    int const a[10] = {};

    auto x = a; // const int *x = a; dizinin ilk ogesinin adresine donusturulecek

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int main()
{
    auto x = "orhan"; //const char *
    x;
    //const char * y = "orhan";

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int foo(int);

int main()
{
   auto x = foo;

   x(2); //foo(2);

   //int (*x)(int) = foo; //bununla arasında hiç bir fark yoktur

}


/***************************************************/
/***************************************************/

2
auto &x = expr;


#include <iostream>

using namespace std;


int main()
{
    //l value referans olmalı yoksa sentaks hatası
    auto &x = 10; //sentaks hatası
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int y = 10;
    auto &x = y; //int & x

    x;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int ***ptr;
    auto &x = ptr; //gecerli

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int (*fptr)(int, int);
    auto &x = fptr; //geçerli
    x;
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    const int x = 10;

    auto &r = x;  //constluk düşmez

    //const int %r = x;

    r = 12; //sentaks hatası


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int a[5] = { 0 };
    auto &r = a;
    //int [5]
    //int (&r)[5] = a;

    r[2] = 23;


}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    const int a[5] = { 0 };
    auto &r = a;
    //const int [5]
    //const int (&r)[5] = a;

    r[2] = 23; //sentaks hatsı


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    auto &x = "orhan";
    //const char[6]
    //const char (&x)[6] = "orhan"

    x;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int foo(int, int);

int main()
{
    int (*fptr)(int, int) = &foo;

    auto &rfp = foo;
    //int (&)(int, int);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    const auto y = x; //gecerli

    y = 12; //const oldugundan gecersiz

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    const auto &y = x; //gecerli

    y = 12; //const oldugundan gecersiz


}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    static int x = 10;

    auto y = x; // int

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    auto &r1 = x; // int &r1
    const auto &r2 = x;

    r2;

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    int *ptr = &x;


    //ikiside int *
    auto ptr1 = &x; //int *

    ptr1;

    auto *p = &x; //int *

    p;

}


/***************************************************/
/***************************************************/

Fonksiyıonların varsayılan argüman alması
default arguments




#include <iostream>

using namespace std;


void func(int x, int y, int z);

int main()
{
    func(10, 20, 30);
    func(2, 3); //sentaks hatası
    func(); //sentaks hatası
    func(1, 2, 3, 4); //sentaks hatası
}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//tek isna cözüm bu suan kibilgilerimizle

void func(int x, ...);

int main()
{
    func(10, 20, 30);
    func(2, 3); //sentaks hatası
    func(2); //sentaks hatası
    func(1, 2, 3, 4); //sentaks hatası

    printf(const char *p, ...); //variadic fonksiyondu
}


/***************************************************/
/***************************************************/


n tane parametren var


default fonksiyonlar

compile time ilişkin n


#include <iostream>

using namespace std;

void func(int, int, int = 10);

int main()
{
    func(1, 2, 3); //func(1, 2, 3);
    func(1, 2); //func(1, 2, 10);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

void func(int = 30, int = 20, int = 10);


int main()
{
    func(); //func(30, 20, 10);
    func(1); //func(1, 20, 10)
    func(1, 2, 3); //func(1, 2, 3);
    func(1, 2); //func(1, 2, 10);

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

void func(int, int = 20, int); //sentaks hatası


int main()
{

}


/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;

void func(int &r);  //Lvalue ile cagırmalıyım
void foo(const int &r); //Lvalue ve Rvalue ile cagırabiliriz
int &bar(void); //dogrudan Lvalue

int main()
{
    const int &r = 10;
    //int temp = 10;

    int x = bar();
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//fonksiyon cagırma yontemleri

//T bir türü temsil eder
void f1(T x); //call by value -- deger kopyalama
void f2(T *p); //set fonksiyonu --- nesnenin adresi ile
void f3(const T *p); //get fonksiyon -- nesnenin sadece degerini okuma

//referans karsılıkları
void f22(T &r); //call by referans
void f33(const T &r);

//fonksiyonun geri dönüşleri inceleme

const T *f5(); //adres geri doner ama salt okuma amaclı
const T &f55(); //referans geri doner salt okuma amaclı


int main()
{

}


/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//parametrelere isim verilebilir
void func(int x, int y, int z = 30);

int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

int g = 45;

void func(int x, int y, int z = g + 5);

int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

int g = 45;
int func(int x, int y);
void foo(int x = func(2, 3));

int main()
{
    foo();
    foo(14);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

int func(int x, int y = 99);
void foo(int x = func(45));

int main()
{
    foo(); //foo(func(45, 99));
    foo(14); //foo(14);
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

int foo()
{
    cout << "foo cagrildi\n";
    return 1;
}

int g = foo();

int main()
{
    cout << "main cagrildi\n";
}


/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

void func(int x = 1, int y = 2, int z = 5);

int main()
{
    func();
    func(10, 20);
    func(10, 20, 30);
    func(10);

}

void func(int x, int y, int z)
{
    cout << x << ", " << y << ", " << z << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//varsayılan arguman

int g = 23;

void func(int &r = g); //varsayılan arguman olarak referans seklinde verebiliriz

int main()
{
    int a = 4;
    func(a);
    func(); //func(g);
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

void func(int *p = nullptr); //varsayılan arguman olarak pointer seklinde verebiliriz

int main()
{
    int a = 4;
    func(&a);
    func(); //func(nullptr);

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

void func(const char *p = "orhan"); //varsayılan arguman olarak string literals seklinde verebiliriz

int main()
{
    func("ozturk");
    func(); //func("orhan");

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//varsayılan arguman

//orhan.hpp
void func(int x, int y, int z);

//fonksiyon overloading ile bunu yapabilirim
void func(int x, int y, int z = 0);


int main()
{
    func(1, 2, 3);
    func(1, 2);

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//varsayılan arguman

//orhan.hpp
void func(int x, int y, int z = 0);
void func(int x, int y = 10, int z);


int main()
{
    func(1, 2, 3);
    func(1, 2); //func(1, 2, 0)
    func(1); //func(1, 10, 0);

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//varsayılan arguman

void process_date(int day, int mon, int year = -1);

//-1 ile devam ederse  sunu yaparım
//farklı bir deger gecilirse sunu yaparım

int main()
{

}



/***************************************************/
/***************************************************/


Sag taraf referansı - R value referance

R value referance  (C++11) ile eklendi


R value referance'ın dile eklenme sebepleri
1- move semantics (tasima semantiği) -- sınıflar konusunda
2- perfect forwarding (mukemmel gonderim) -- Generic programlamada



L value referans

T &r = x;

T &r = 10; //sentaks hatası



sag taraf referansı

T &&r = 10;




#include <iostream>

using namespace std;

//R value referance


int main()
{

    int &&r = 10; //ilk deger verilir

    r;

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//R value referance


int main()
{

    int &&r; //sentaks hatası -- ilk deger verilmez

    r;

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance


int main()
{
    int x = 10;

    int &&r = x; //sentaks hatası -- L value atayamayız

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance


int main()
{
    int x = 10;

    int &&r = x + 5; // + operatoru --> R value

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance


int main()
{
    int x = 10;

    int & &r = x + 5; //sentask hatası

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance

int foo();

int main()
{
    int &&r = foo(); //gecerli

}



/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

//R value referance

int &foo();

int main()
{
    int &&r = foo(); //sentaks hatası

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance

//mulakat sorusu



int main()
{
    int &&r = 10;
    //r R value mu L value mu
    r; //L value

    int &rf = r; //kanıt


}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//R value referance

//mulakat sorusu



int main()
{
    int &&r = 10;

    r = 20; // gecerli ama ileride anlayacaz bunun nedenini


}



/***************************************************/
/***************************************************/



Bazı operatorlerin olsutrdugu ifaleri

R value
 a > b
  x == y
  x && y
  !x

 x & y
 x++
 x--


Lvalue

 ++x
 --x
 x, y

 x > 0 ? x : y; ternary operator
 (x = 20)   lvalue
 (x = 20) = 30;



T &&r = R val
T &&r; //sentaks hatası



Auto keyword -- type deduction

auto x = expr;

auto &x = expr;

auto &&x = expr; //Sakın sakına sag taraf referansı ile karıstırmayınız

Önemli

Tur cıkarımı var ise ve işin içinde && bildirgeci kullanılmıs ise
böyle tanıtılan isimlere
forwarding referance yada universal referance denmektedir .


-----------------------------------

Type deduction' a geri donelim

decaltype (specifier)

decaltype(ifade) // bu bir türe karsılık gelir ornegin int


#include <iostream>

using namespace std;

int main()
{
    int x = 10;

    decltype (x); //int turu

    decltype(x) y = 10; // y nin turu int türünden ilk deger 10 ile geldi hayata

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int x = 10;

void func(decltype (x)); //function parameters

int main()
{

}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int x = 10;

//fonksiyonun geri donusu içinde kullanılabilir
decltype (x) func(decltype (x)); //function parameters

int main()
{

}

/***************************************************/
/***************************************************/


decaltype ilişkin 2 kural seti var

1- kural seti  -- parantez içine dogrudan bir isim girilmesi

   decaltype(x)
   decaltype(x.y)
   decaltype(ptr->a)



#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int ival;
    double dval;
    Data data;

    decltype (ival) x;
    decltype (dval) y;
    decltype (data) z;
    decltype (data.mx) t; //int

    Data *p = &data;
    decltype (p->mx); //int



}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    const int cx = 10;
    decltype (cx) x = 20; //const luk auto ki gibi düşmez
    //const int x = 20;

    x = 30; //sentaks hatası

}



/***************************************************/
/***************************************************/
#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int x = 10;
    int &r = x;
    decltype (r); //int & turudur, auto daki gibi referanslık düşmez

    auto t = r; //int

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int x = 10;
    int &r = x;
    decltype (r) y; //sentaks hatası ilk deger verilmediğinden
    //int & turudur, auto daki gibi referanslık düşmez


}



/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


struct Data{
    int mx;
};

int main()
{
    int a[] = {1, 2, 3, 4};

    decltype (a) b; //int b[4], dizi pointer'a donusturulmez

}



/***************************************************/
/***************************************************/

2- kural decaltype

  decaltype(expr)  isim olmayan durumlar

  decaltype((x))  2 kural seti
  decaltype(x)  1 kural icin isim expr



decaltype(19)
decaltype(x+5)
decaltype(x++)
decaltype((y))
decaltype(*ptr)
decaltype(a[5])




#include <iostream>

using namespace std;


int main()
{
    //PR VALUE
    decltype (10) x;    //int turu
    x;
}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //İFADE pr value ise

    int x = 10;
    decltype (x + 3.4) y;    //double turu

}



/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int main()
{
    //İFADE L value ise

    int x = 10;
    decltype (++x) y = x;    //int &
    //int &y = x
    y = 22;
    cout << "x : " << x << "\n";

}



/***************************************************/
/***************************************************/


Eğer decaltype belirtecinin operandi bir isim değil ise
isim formunda olmayan bir ifade ise bu durumda


PR value expresion deger kategorisinde ise
decaltype ile elde edilen tur T turudur

L value expresion deger kategorisinde ise
decaltype ile elde edilen tur T& turudur

X value expression deger kategorisinde ise
decaltype ile elde edilen tur T && turudur



#include <iostream>

using namespace std;


int main()
{
    int x = 10;
    int *ptr = &x;

    //L value bir expression
    decltype (*ptr) y = x;    //int &
    y = 22;
    cout << "x : " << x << "\n";

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    int x = 10;

    int a[10][20] {};

    //L value
    decltype (a[2][3]) y = x;    //int &
    y = 22;
    cout << "x : " << x << "\n";

}

/***************************************************/
/***************************************************/




#include <iostream>

using namespace std;

int &&foo();

int main()
{

    decltype (foo()) y = 10; //int &&


}

/***************************************************/
/***************************************************/

ozet

decaltype(isim) bu değişkenin turu ne ise türü o ve const'luk ve referanslık düşmez
decaltype(isim formunda değil ise) T , T&, T&&



#include <iostream>

using namespace std;

int &&foo();

int main()
{
    int x = 10;

    decltype (x); //int

    //Lvalue
    decltype ((x)); //int &

}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;

    ++x;
    size_t y = sizeof (++x);
    //derleyici burada kod uretme
    //unevaluated contex devererye girigi için sizeof operatorunda ++x için kod üretilmez

    cout << "x = " << x << "\n";

}

/***************************************************/
/***************************************************/


decaltype da unevaluated contex olusturur



#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;

    decltype (++x) y = x;
    //unevaluated contex

    cout << "x = " << x << "\n";
}

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;

    decltype (++x) y = 10; //int & oldugunda sentask hatası
    //unevaluated contex

    cout << "x = " << x << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//soru mulakat

int main()
{
    int x = 10;
    int *ptr = nullptr;

    decltype (*ptr) y = x; //gecerli
    //burada nullptr isleme alınmaz
    //eger ele alınırsa tanımsız davranış olur

    cout << "x = " << x << "\n";
}

/***************************************************/
/***************************************************/


constexpr

C++11 ile dile aklenen anahtarsözcük

const'tan ayrı bir anahtarsözcük



#include <iostream>

using namespace std;


int main()
{
    //C++ da const anahtar sözcüğü ile olsuturulan ifade hayata ilk deger alarak gelmek zorunda
    const int x = 10;
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    //C++ da const anahtar sözcüğü ile olsuturulan ifade hayata ilk deger alarak gelmek zorunda
    const int x = 10;

    int a[x] = { 0 };

    int y = 12;

    switch (10) {
        case x: break;
    }
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


int main()
{
    int y = 15;
    //
    //
    const int x = y + 10; //sabit ifadesi olmuyordu

    int a[x] = { 0 }; //sentaks hatası

}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


int foo();

int main()
{
    const int x = foo(); //sabit ifadesi olmuyordu

    int a[x] = { 0 }; //sentaks hatası
}

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

int main()
{
    //ilk deger vermek zorunlu
    //x ifadesi salt okuma amaçlı
    constexpr int x = 10;

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    int y = 10;
    constexpr int x = y; //sentaks

    //x ilk deger veren ifadeler sabit ifadeleri olması lazım
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    constexpr int x = 10;
    constexpr int y = 20;
    constexpr int z = 30;

    (x + y + z) * 3;

    int a[(x + y + z) * 3];

}

/***************************************************/
/***************************************************/


constexpr  c++11 fonksiyon modeli


constexpr functions

öyle bir fonksiyon ki belirli koşullar altında çağrı yapıldıgında derleme zamanında (compile)
geri dönüş degeri sabit olarak elde edilecek


constexpr C++11 ile ilk geldiğinde kısıltlamalı haldeydi
constexpr functions oneliner olmak zorundaydı, yani sadece returnden olusan fonksiyonlardı

constexpr int func(int x)
{
   return x *10;
}


C++14 ve C++17 ile böyle koşullar kalktı


#include <iostream>

using namespace std;


//sonuc ürettiği zaman compile time da
//onliner bir fonksiyon
constexpr int square(int a)
{
    return a * a;
}

int main()
{


}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//sonuc ürettiği zaman compile time da
//onliner bir fonksiyon
constexpr int square(int a)
{
    return a * a;
}

constexpr int ndigit(int ival)
{
    if(ival == 0)
        return 1;

    int digit_count = 0;

    while (ival) {
        ++digit_count;
        ival /= 10;
    }

    return digit_count;
}


int main()
{
    constexpr int a = 10;
    constexpr int b = 20;

    square(a); //sabir ifade

    int arr[square(a)];

    square(a * b + 3);

    int dArr[square(a * b + 3)];


    ndigit(a * b);
    ndigit(a * b + 1200);


    ndigit(square(a * b + 3));

    int ar[ndigit(square(a * b + 3))] = { 0 };


}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//constexpr fonksiyonları pure olmalı , static anahtar değişken tanımlama kanul etmez
constexpr int square(int a)
{
    static int y = 12;//error

    return a * a;
}

int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


class MyClass{

};

//literal type kategorisinden olmalı geir dönüş türü
constexpr int func(MyClass x)
{

    return x;
}


int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//constexpr fonksiyonlara gonderilen deger sabit ifadesi olmak zorunda değil
constexpr int func(int x)
{
    return x;
}


int main()
{
    int y;
    cout << "bir sayi giriniz : ";
    cin >> y;

    func(y); //gecerli
    //buradaki hesaplamayı compile time da yapmayacak run time da yapacak

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;


//constexpr fonksiyonlara gonderilen deger sabit ifadesi olmak zorunda değil
constexpr int func(int x)
{
    return x;
}

int main()
{
    int y;
    cout << "bir sayi giriniz : ";
    cin >> y;

    constexpr int b = 10;
    constexpr int a = func(y); //sentaks hatası

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

constexpr int factorial(int x)
{
    return x < 2 ? 1 : x * factorial(x - 1);
}

constexpr int ndigit(int ival)
{
    if(ival == 0)
        return 1;

    int digit_count = 0;

    while (ival) {
        ++digit_count;
        ival /= 10;
    }

    return digit_count;
}

int main()
{
    constexpr int x = 5;

    constexpr int y = ndigit(factorial(x + 5));
    //derleme zamamnında elde ettik

}

/***************************************************/
/***************************************************/


derleyici constexpr kodunu görmeliki one göre sonuc üretsin
bu sebepten constexpr fonksiyonları baslık dosyasında olmalıdır

.h
.hpp
.cpp





#include <iostream>

using namespace std;


int main()
{
    constexpr auto x = 5; //gecerli

}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

constexpr int get_prime(int x)
{
    constexpr int a[] = {0, 2, 22, 333, 44, 55, 26, 17, 68};

    return a[x];
}

int main()
{
    constexpr int a = 3;

    get_prime(a);
}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

constexpr int get_prime(int x)
{
    constexpr int a[] = {0, 2, 22, 333, 44, 55, 26, 17, 68};

    return a[x];
}

int main()
{
    constexpr int x = 3;

    decltype (x) y = 5;

    get_prime(y);
}

/***************************************************/
/***************************************************/

C++ da tür dönüştürme operatörleri

c de kullnaılan type cast operatörü
double x;
int y = (int)x;


C++ da 4 tane tür dönüştürme operatörü var

static_cast
const_cast
reinterpret_cast
dynamic_cast


C de bazı örnekler

#include <iostream>

using namespace std;


int main()
{
    int x = 10;
    int y = 6;

    (double)x/y;
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    unsigned int uval = 6567454; //4 byte

    //2 btye
    unsigned short *p = (unsigned short *)&uval;
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

int main()
{
    //istinai durum
    unsigned int uval = 6567454; //4 byte

    char *p = (char *)&uval;//gecerli istisnai durum
}

/***************************************************/
/***************************************************/




1- static_cast  ---> static donusumler için
2- const_cast  ----> const donusumler için
3- reinterpret_cast ---> adreslere donusum için
4- dynamic_cast --> inharetince kalıtım için


kullanım

 static_cast<double>(ival)






#include <iostream>
#include <cstdlib>

using namespace std;

int main()
{
    srand(static_cast<unsigned int>(time(nullptr)));

    int x, y;
    cout << "iki tam sayi griiniz : ";
    cin >> x >> y;

    double t = static_cast<double>(x) / y;

}

/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;


//c nin temel konuları

int main()
{
    int x = -1;
    unsigned int y = 1;

    if(x > y)
        cout << "evet dogru\n"; //burayı yazdıracak
    else
        cout << "hayir dogru degil\n";

}

/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

//c nin temel konuları

int main()
{
    char x = 178;

    if(x == 178)
        cout << "evet dogru\n";
    else
        cout << "hayir dogru degil\n"; //bu kısmı ele alacak

}

/***************************************************/
/***************************************************/




#include <iostream>
#include <cstdlib>

using namespace std;

char *Strchr(const char *p, int c)
{
    while (*p) {
        if(*p == c){
            return const_cast<char *>(p);
        }
    }

   //return const_cast<char *>(p);
}

int main()
{

}

/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

int main()
{
    double dval = 123.3344;
    unsigned char *p = reinterpret_cast<unsigned char *>(&dval);

}

/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

int main()
{
    double dval = 123.3344;
    unsigned char *p = const_cast<unsigned char *>(&dval); //sentask hatası

    for (size_t i = 0; i < sizeof (dval); ++i)
    {
        cout <<  p[i] << " ";
    }
}

/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

enum Color {Black, Green, White};

int main()
{
    Color mycolor{Green};

    int x = mycolor; //bu legal

    mycolor = 3; //sentaks hatası

    int ival = 2;

    mycolor = static_cast<Color>(3);
    mycolor = static_cast<Color>(ival);

}

/***************************************************/
/***************************************************/

//#include <iostream>
#include <cstdlib>

//using namespace std;

enum Color {Black, Green, White};

int main()
{
    size_t n = 1000;

    //char *p = (char *)malloc(n);

    char *p = static_cast<char *>(malloc(n));
    //bu örnek için istisna
}

/***************************************************/
/***************************************************/


//#include <iostream>
#include <cstdlib>

//using namespace std;

enum Color {Black, Green, White};

int main()
{
    const double *ptr = nullptr;

    //char *p = const_cast<char *>(ptr); //legal degil
    //char *p1 = reinterpret_cast<char *>(ptr); //legal değil

    char *p = reinterpret_cast<char *>(const_cast<double *>(ptr));
    char *p1 = const_cast<char *>(reinterpret_cast<const char *>(ptr));


}

/***************************************************/
/***************************************************/

İşlev yüklemesi -- Function overloading


N tane fonksiyon var ama isimleri aynı verme işlemidir


Peki bmyle bir işlemi yapmanın run time maliyeti var mı ?
Hayır



static binding    ---   early binding

static binding
Bir fonksiyonun çağrısı karsılgı hangi donksiyonun cagrıldıgını çeviri sürecinde anlasılıyorsa
yani derleyici koda bakarak hangi fonksiypnun çağrıldıgını anlıyor ise işlev çağrısnın çağrılacak işleve
baglnaması biçimine static binding - early binding denir


dynamic binding  --- late binding
Hangi fonksiyonun çağrıldıgını programın çalışma zamanında belli oluyor ise
bu türlerde fonksiyona baglanması  dynamic binding  --- late binding denir


fonksiyon overloading  static binding -- early binding dir

function overloading var mı?
varsa hangisini çağıracak?

f1
f1
f1
f1

function overload resolution

------------------------------------------


işlev yüklemesinini olabilmesi için

1- aynı isimli işlevler aynı kapsam (scope) bildirilmesi yada tanımlanması gerekli
2- aynı isimli işlevlerin imzaları farklı olacak


function signature -- imza

geri dönüş türü hariç kalan kısım imzasıdır fonksiyonun
int func(int , double); //func, int, double


#include <iostream>
#include <cstdlib>

using namespace std;

//function redeclaration

int foo(int x, int y); // func, int, int
int foo(int, int); //func, int, int

int main()
{
}

int foo(int x, int y)
{

}

int foo(int, int)
{

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//function overloading değil

int foo(int x, int y); // func, int, int
double foo(int, int); //func, int, int

int main()
{
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

//function overloading -- EVET

int foo(int x, int y); // func, int, int
double foo(int, int, int); //func, int, int, int

int main()
{
}

int foo(int x, int y) // func, int, int
{
    return 1;
}

double foo(int, int, int) //func, int, int, int
{
    return 2.2;
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//type alias  - tür eş isimleri

typedef int Int32;

//function overloading -- HAYIR
//redeclaration
int foo(int); // func, int,
int foo(Int32); //func, int,

int main()
{
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//redeclaration
int foo(int){} //foo, int
int foo(const int){} //foo ,int

int main()
{
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//Function overloading
//const overloading denir

void foo(int *){}
void foo(const int *){}

int main()
{
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//Function overloading
//const overloading denir

void foo(int &){}
void foo(const int &){}

int main()
{
}


/***************************************************/
/***************************************************/

void foo(T *){}
void foo(const T *){}

void foo(T &){}
void foo(const T &){}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//redeclaration

void foo(int *p){}
void foo(int *const p){} //const burada parametrenini kendisidir

int main()
{

}


/***************************************************/
/***************************************************/




#include <iostream>
#include <cstdlib>

using namespace std;

//function overloading

void fuu(int x, int y, int z = 10); //fuu, int, int ,int
void fuu(int x, int y); //fuu, int, int

int main()
{

}


/***************************************************/
/***************************************************/
#include <iostream>
#include <cstdlib>

using namespace std;

//redeclaration

void fuu(int x, int y = 10); //fuu, int, int
void fuu(int x, int y); //fuu, int, int

int main()
{

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

//function overloading

//void fuu(int); //fuu, int
//void fuu(int &); //fuu, int &

int main()
{

}


/***************************************************/
/***************************************************/



#include <iostream>
#include <cstdlib>

using namespace std;

//function overloading

//void fuu(int &); //fuu, int &
//void fuu(int &&); //fuu, int &&

int main()
{

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//function overloading

//void fuu(int); //fuu, int
//void fuu(bool); //fuu, bool

int main()
{

}


/***************************************************/
/***************************************************/

Function overloading resolution 2 durum söz konusudur

1- geçersiz syntax error

  a- no match

   void func(int);
   void func(int, int);
   void func(int, double);

    //cagrı
    func(nullptr); //sentaks hatası

  b- ambiguity --- çift anlamlılı hatası

    iki veya daha fazla secenek var fakat seçilebilirlik kireteri yok aralarında ise


2- geçerli (hangi işlevin çağrıldığı anlaşılması)



#include <iostream>
#include <cstdlib>

using namespace std;


//tahmin
//long double'in char 'üstünlüğü yok
int func(char c);
int func(long double d);

int main()
{
    double dval = 4.4;

    func(dval);
}


/***************************************************/
/***************************************************/


function overloading resolution 3 aşamada gerçekleşir


1- aday fonksiyonlar

  çağrıda kullanılan isimle aynı olmasıdır. Aynı scope'ta

{
 void func(int *)
 void func(int, int)
 void func(double)

}
 func(11);


2- Uygun fonksiyonlar - Eger fonksiyon cagrısı ile fonksiyonun parametre sayısı eşit ise



#include <iostream>
#include <cstdlib>

using namespace std;

enum Color {Red, White, Green};

void func(int);
void func(bool);
void func(int ,int);
void func(int *);
void func(int, int = 1, double = 3.4);
void func(Color);

int main()
{

    //soru 1- kac tane aday fonksiyonu 6 tane
    func(3.6);
    //soru 2 - kac tane uygun fonksiyon var

    /*
    void func(int); //evet uygun -- double 'dan int'e donusum var
    void func(bool); // evet uygun -- double'da bool'a donusum var
    void func(int ,int); //uygun değil parametre sayısı eşit değil
    void func(int *); //uygun değil, double'dan int* donusum yok
    void func(int, int = 1, double = 3.4); //uygun evet , double'dan int'e dönüşüm var
    void func(Color); //uygun değil, double'dan enum'a donusum yok
    */


}


/***************************************************/
/***************************************************/



#include <iostream>
#include <cstdlib>

using namespace std;

enum Color {Red, White, Green};

void func(int);
void func(bool);
void func(int ,int);
void func(int *);
void func(int, int = 1, double = 3.4);
void func(Color);

int main()
{

    func(nullptr); //sadece uygun bir fonksiyon var

}


/***************************************************/
/***************************************************/

3- En az 2 tane uygun fonksiyondan bahsetmemiz lazım ki 3'cü aşama olsun

   burada dilin kuralarına göre bir seçim yapacak veya yapamayıp sentaks hatası verecek -- ambiguity


kalitesizden kaliteliye donusum

1- variadic conversion
2- user-defined conversion   --- fonksiyon cagrısı ile bir donusum yapılıyor


#include <iostream>
#include <cstdlib>

using namespace std;

struct Data{

};

int main()
{
    Data mydata;

    mydata = 10; ///sentaks hatası

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

//ileride görecez detaylı olarak
//bu user define conversion  denir

struct Data{
    Data();
    Data(int);
};

int main()
{
    Data mydata;

    mydata = 10;

}


/***************************************************/
/***************************************************/




3- standart convertion

int --> int *  // donusum yok
int --> double //var
int --> char // var
int --> long double //var
int * --> void *//var
void * ---> int *//yok
enum --> int //var
int --> enum //yok



void func(double);
void func(int);

func(3.4f);


a- exact match -- tam uyum


-Lvalue to R value transformation
- array to pointer conversion
-const convertion
-function to pointer conversion


void func(int x);

func(y);  //L value to R value transformation
func(10);

void func(const int *p);

int x = 10;

func(&x); //const conversion


void func(int *p);

int a[10]; { 0 };
func(a); //func(&a[0]) // array to pointer conversion


void func(void (*fp)(int));
void f1(int);
void f2(int);

func(&f1);
func(f2);  //function to pointer conversion




b- promotion -- terfi yukseltme

integral promotion

#include <iostream>
#include <cstdlib>

using namespace std;


int main()
{
    char c1 = 10;
    char c2 = 5;

    short s1 = 100;
    short s2 = 40;

    c1 + c2; //int

    s1 + s2; //int

}


/***************************************************/
/***************************************************/


float  --> double promotion




c- conversion
   yukarıda bahsi gecen konuların dışında kalan donusumler conversion dönüşümleridir



#include <iostream>
#include <cstdlib>

using namespace std;


void func(int);
void func(double);

int main()
{
   func(12); //int
   func(1.1f); // double

   unsigned int uval = 27;
   func(uval); //sentaks hatası ambiguity
   //unsigned int --> int conversion var
   //unsigned int --> double conversion var


}


/***************************************************/
/***************************************************/



#include <iostream>
#include <cstdlib>

using namespace std;


void func(long double);
void func(char);

int main()
{
    func(2.5); //sentask hatası ambiguity
}


/***************************************************/
/***************************************************/




#include <iostream>
#include <cstdlib>

using namespace std;


void func(double);
void func(char);

int main()
{
    float f = 12.22;
    func(f); //gecerli
    //cunku double promotion
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;


void func(int);
void func(bool);

int main()
{
    func(10 > 5);//gecerli bool
    //cunku promotion
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;


void func(int);
void func(char);

int main()
{
    func('A');//gecerli char
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;


void func(int);
void func(int, int = 5);

int main()
{
    func(10);//ambiguity
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;


void func(int); //call by value
void func(int &); //call by referans

int main()
{
    int x = 10;

    func(x);//ambiguity -- ne call by value ne call by reference secilebilirlik yok
    func(20); //gecerli
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

void func(const int *);
void func(int *);

int main()
{
    const int x = 10;
    func(&x); //gecerli const int * cagrılacak.  2.cisi zaten uygun funksiyon değil
}


/***************************************************/
/***************************************************/




#include <iostream>
#include <cstdlib>

using namespace std;

void func(const int *);
void func(int *);

int main()
{
    int x = 10;
    func(&x); //gecerli int * cagrılacak.
}

1-- aday
2-- uygun mu
3-- hangisi secilcek
    a- exact mach
    b- promation
    c- conversion

/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(const int &);
void func(int &);

int main()
{
    const int x = 10;

    func(x); //gecerli const int & cagrıalcak

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(const int &);
void func(int &);

int main()
{
    int x = 10;

    func(x); //gecerli int & cagrıalcak

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(double);
void func(int *ptr);

int main()
{
    int x = 0;
    func(x); //gecerli double cagrılacak , 2. cisi uygun değil
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

void func(double);
void func(int *ptr);

int main()
{
    //özel durum
    func(0); //ambiguity
    //normalde double cagrılması bekleniyor
    //0 --> nullptr donusum var

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

void func(int);
void func(int *ptr);

int main()
{
    //özel durum
    func(0); //int parametreli cagrılacak
    //int parametre olan exact mach
    //pointer convertion

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

//herhangi türden void * donusumu var
void func(void *);


int main()
{
   int ival = 10;
   func(&ival); //legal

}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

void func(bool);

int main()
{
   int ival = 10;
   func(&ival); //legal
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(bool);
void func(void *);

int main()
{
   int ival = 10;
   func(&ival); //gecerli
   //aslında iki fonksiyonada std convertion var
   //ama void * kazanıyor
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(int);
void func(int *);

int main()
{
   func(0); //gecerli
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

void func(double);
void func(int *);

int main()
{
   func(0); //ambiguity
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

void func(double);
void func(int *);

int main()
{
   func(nullptr); //gecerli
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(double *);
void func(int *);

int main()
{
   func(nullptr); //sentaks hatası --kafası karısır
}


/***************************************************/
/***************************************************/

#include <iostream>
#include <cstdlib>

using namespace std;

void func(int &r);
void func(int &&r);

int main()
{
   int x = 10;
   func(x);// ilki cagrılır L value reference
   //R value ile cagırsaydık alttaki cagrılırdı
}


/***************************************************/
/***************************************************/

Çok parametreli overloading için

Bir fonksiyonun bir parametrede ustunluk saglmaası gerekiyor ve diger parametrelerde
daha kötü olmayacak aynı olabilir veya üstün olabilir



#include <iostream>
#include <cstdlib>

using namespace std;

void func(int, double, long);   // h  m  m
void func(double, int, int);    // m  m  m
void func(float, float, float); // m  m  m

int main()
{
    func(12, 6u, 4.5); //1. cisi cagrılır

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(int, double, long);   // h  m  m
void func(double, int, int);    // m  h  m
void func(float, float, float); // m  m  m

int main()
{
    func(12, 15, 4.5); //ambiguity

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(int, double, long);   // m  m  m
void func(double, int, int);    // h  m  m
void func(float, float, float); // m  m  m

int main()
{
    func(3.1, 6u, 5.5);
}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;

void func(int, double, long);   // m  m  m
void func(double, int, int);    // m  h  m
void func(float, float, float); // m  m  m

int main()
{
    func(12u, 14, 5.5); //2.cisi
}


/***************************************************/
/***************************************************/

enum  --- numaralandırma


C deki enum int'ti arkasındaki tür
underlying type --> int denir

C++ da underlying type derleyiciye baglı ve numaralandırmalara verdiğimiz
degerlerin ne olduguna baglı olarak sizeof degişir



enum Color{White, Black, Gray, Gree};



#include <iostream>
#include <cstdlib>

using namespace std;

enum Color{White, Gray, Green, Balck};

//1. kötü özelliği tür dönüşümler,

int main()
{
    Color myColor = Gray;

    int ival = 5;

    myColor = ival; //sentask hatası
    ival = myColor; //gecerli

    //böyle olması birçok kodlama hatası tetikliyor
    //yani problem enumlardan int'e implicit type convertion olması

}


/***************************************************/
/***************************************************/




#include <iostream>
#include <cstdlib>

using namespace std;

enum Color{White, Gray, Green, Balck};

//2. kötü özellik numaralandırma türünün
//underlyen türü derleyicieye baglı oldugu için
//numaralandırma türlerin forward declaration yapılamıyordu
//incomplte type / complete type -- eksik tür -- tamamlanmı tür

//yapılar numaralandırmalar birlikler
//complete type / incomplete type olabilir C de

//derleyici tanımı görmesi complete type
//derleyici tür bilgisi oldgunu biliyor
//ama tanımı göremiyorsa incomplete type dir

//complete type
struct Data{
    int x, y, z;
};

//incomplete type
struct Data1;

int main()
{
    //incomplete type
    //tanımlama yapamayız cunku ne kadar yer alacagını kestiremeyiz
    //Data1 data1; //sentaks hatası
    Data data; //gecerli

}


/***************************************************/
/***************************************************/


#include <iostream>
#include <cstdlib>

using namespace std;


enum Color{Whıte, Black, Gray, Green};

//3. kötü özellik numaralandırma türünün

//screen.h
//#include "screen.h"
enum ScreenColor {Magenta, Gray, Blue, Red};

//#include "traffic.h"
enum TrafficLight {Yellow, Green, Red};

//Aynı scope taki enum varklıklara aynı scope ta olamaz
//Gray - Red -- Green tekinde olması gerek

//1. çözüm isimlerin farklı olması
//2.çözüm class elemanı olarak yazmak


class Screen{
    enum ScreenColor {Magenta, Gray, Blue, Red};
};

//3. çözüm isim alnı içine almak  --- namespace

int main()
{


}


/***************************************************/
/***************************************************/

modern C++ da yenilikler


1. underlying type programcı secebilir

enum Color : int {Red, White, Black};
enum Color : int;

2. enum Class'lar eklendi daha önemli bir ekelenti

-bu sayede diger türlere otomatik tür donusumu yok
-numaralandırma sabitlerinin scope'u degisti
-isim cakısmasından kurtulmus olduk



#include <iostream>
#include <cstdlib>

using namespace std;

enum class TrafficLight : int {Black, White, Yellow};
enum class Color : int {Black, White, Yellow};

int main()
{
   Color myColor = Color::Black;
   int ival = myColor; //sentaks hatası artık

   //ben bilerek yapmak istiyorum bu atamayı
   unsigned int val = static_cast<unsigned int>(myColor);
}


/***************************************************/
/***************************************************/



#include <iostream>
#include <cstdlib>

using namespace std;

enum class Color : unsigned long {Black, White, Yellow};

int main()
{
    const char *const p[] = {"Black", "White", "Yellow"};

    p[Color::Black]; //int e donusum yok -- yani otomatik donusum yok


    cout << p[static_cast<int>(Color::White)] << "\n"; //böyle yapabiliriz
}


/***************************************************/
/***************************************************/


Extern C Bildirimi

#include <iostream>
#include <cstdlib>

using namespace std;

int func(int x, int y);

int main()
{
  //linker aşamasında çözümleyemez
  auto a = func(2, 6);
}


/***************************************************/
/***************************************************/

Bildirim

extern "C" int func(int, int);

func aslında external bir c fonksiyonu oldugu anlaşılıyor
sen bunu obje koda yazdıgında C tarzı yaz


extern "C" int func1(int, int);
extern "C" int func2(int, int);
extern "C" int func3(int, int);
extern "C" int func4(int, int);

böyle yazmaktansa şöyle

extern "C" {
  int func1(int, int);
  int func2(int, int);
  int func3(int, int);
}

------------------------------------------

predefined symbolic constants


neden buna ihtiyac var

C ve C++ için tek bir kutuphane kullanmak


#include <iostream>
#include <cstdlib>

using namespace std;

/*
extern "C" {
  int func1(int, int);
  int func2(int, int);
  int func3(int, int);
}
*/


#ifdef __cplusplus
    extern "C" {
#endif
    int func1(int, int);
    int func2(int, int);
    int func3(int, int);
#ifdef __cplusplus
    }
#endif


int main()
{

}


/***************************************************/
/***************************************************/

10.Ders 25.02.2023 - Cumartesi

Classes --- Sınıflar

data abstraction  -- veri soyutlama
problem domainde varlıklar var. Programlama dilinde yazılımsal olarak varlıkları temsil etmektir.

C++ da sağlayan araç class'lardır


Sınıflar user defined typedır
C de struct'ra yapı denir --> C++ da structlar aslında sınıftır

class definition -- tanım
class declaration -- bildirim




#include <iostream>

using namespace std;

//class tag
class Myclass{

};

//struct ile de sınıf olusturulur
struct Mystruct{ //bunu ileride konuşacagız

};



int main()
{

}


/***************************************************/
/***************************************************/


Boş oluşturulan class'lara -- empty class denir


class Myclass{

};




//class tag
class Myclass{
    //bildirimler
    //member lar
};


class member 3 kategoride olabilir

1- data members  -- veri ögeleri
2- member functions -- üye fonksiyonları
3- member type -- type members -- nested types



1- data members  -- veri ögeleri
 a- non-static data member
 b- static data members

2- member functions -- üye fonksiyonları
 a- non-static member functions
  1- non-const member dunctions
  2- const member functions
 b- static member functions

3- member type -- type members -- nested types

#include <iostream>

using namespace std;

class Myclass{
    int x, y; //non static data member
    static double dval; // static data member

    void func(); //non static member dunction
    static int foo(); //static member dunction

    typedef int Word;
    enum class Color {Red, Green, White}; //member type

};


int main()
{

}

/***************************************************/
/***************************************************/

Scope -- kapsam


file scope
block scope
function protatype scope
function scope
class scope


class scope

class Myclass{
  int x, y;
  double dval;
  //
  //
};


-------------------------------

name lookup   --> isim arama

a- sentaks hatası
   -derleyici aradığı ismi bulamaz ise
   -birden fazla bildirim var ama derleyici hangisi odlugunu kestiremiyor -- ambiguity hatası

b- derleyici ismin neyin ismi oldgunu anlar



nesne erşim kontrol menkanizması şu adımlardan geçer

name lookup
context-control
access control (erişim kontrolu)


hangi durumlarda bir isim class scope'ta aranır

a- isim nokta operatörünü sağında kalmış ise (member selection - dot operator)

b- isim ok operatörünü sağında kalmış ise (member selection - arrow operator)

c- isim :: çözünürlük operatörünün sağında kalmışsa (member selection -- scope resolution operator)


A class nesnesi olsun

A.y
A->x
A::z

----------------------------------------------------------


genelde sınıfların baslık dosyasında olur  .h veya .hpp dosyası

cok nadir olarakta .cpp dosyasında tanımı olabilir

yada local yerlerde de olabilir

int main()
{
    //local class
    class Myclass{

    };
}

----------------------------------------------------------

Sınıflarda erişim kontrolu (access specifier) 3 gruba ayrılır

public member
private member
protected member



class Myclass{
public:
 //burası publix memberler

private:
 //burası private member

protected:
 //burası protected memberlar


public:
//burası publix memberler


};

-------------------------

//hiç bir alana ayırmaz isek
//sınıfın içinde tanımlanan herşey private kabul edilir

class Myclass{

};


//bir alan blirtilmezse struct'ta public member olur hepsi
struct Myclass{

}


Programcı sınıfların alnalarını belirler iken belirli bir sırada yapmak zorunda değil




#include <iostream>

using namespace std;

class Myclass{
    int x;  //burası private
    void foo();

public:
    int y;
};

int main()
{
    Myclass my;
    my.y;

}

/***************************************************/
/***************************************************/

biizm uyacagımız yapı bu şekilde

public interface
   public kısımda bulunan isimlerin erişimi herkese açıktır

protected interface
   protected inharetince (miras - kalıtım) oldugu yerlerde sınıfın memberlrina erişim izni vardır
    eğer kalıtım yok ise private özelliği sahip olunur

private interface
   clientların kullnımına kapalı isimlerdir. sadece sınıf kendisi kullanabilir bu isimleri


#include <iostream>

using namespace std;

class Myclass{
public:
    int x;  //burası private
    void foo();

private:
    int y;
};

int main()
{
    Myclass myClass;
    myClass.x;
    myClass.foo();
    myClass.y; //erişim yoktur sentaks hatası

}

/***************************************************/
/***************************************************/

mülakat sorusu

//public ve private scope değildir
//aslında burada tek bir scope vardır
//sentsk hatsı olur isim çakışması

class Myclass{
 public:
   int mx;

 private:
   int mx();

};

/***************************************************/
/***************************************************/


class veri elemanları

sınıfa ne kadar non static veri elemanı koyarsak sizeof o kadar artar
herhangi bildirim yapılmaz ise non static veri elemanıdır eklenen veri elemanı



#include <iostream>

using namespace std;


class Myclass{
   int mx;
};

int main()
{
    cout << "sizeof(Myclass) : " << sizeof (Myclass) << "\n";
}

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;


class Myclass{
   int mx, my;
   double dval;
};

int main()
{
    cout << "sizeof(Myclass) : " << sizeof (Myclass) << "\n";
}

/***************************************************/
/***************************************************/


member functions

class Myclass{
public:
    void func(int);
};

sınıfın dısında tanımlanan fonksiyonlara

global function
free function
stand-alone function


/***************************************************/
/***************************************************/

Sınıfın üye fonksyonları
fonksiyon özelliklerine sahip fakat sadece class scope da yer laması lazım




//Erişim yontemlerimiz

#include <iostream>

using namespace std;


class Myclass{
public:
    //non static member function
    void func(int);
};

int main()
{
    Myclass my1;
    my1.func(2);


    Myclass *my2 = new Myclass();
    my2->func(4);

}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


class Myclass{
public:
    //non static member function
    void func(int);
    //client'lar erişebilir

private:
    int x, y, z;
    //client erişemez
};

int main()
{
    Myclass my1;
    my1.func(2);
}

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:
    void func();
};


int main()
{
    Data mydata;
    Data *p = &mydata;

    //her iki durumda da mydata'nın func'nı cagırmıs olduk
    mydata.func();
    p->func();

}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:
    void func();
};


int main()
{
    //namelookup adımı gerçekleşir

    Data::func();


}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:
    void func();
};

//bu isimde fonksiyon bildirebilirmiyim
//scope'lar farklı oldugu için bildirebiliriz

//peki bunlarda function overloding mi?
//Hayır değil aynı scope ta olması lazım

void func(int);

int main()
{


}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

class Data{
private:
    int x, y, z;

public:
    //sınıfın üye fonksiyonlarını overload edebiliriz
    void func();
    void func(int);
    void func(int, int);
    void func(double);
};


int main()
{
   Data mydata;
   mydata.func(3.4);
   mydata.func(2, 5);
}

/***************************************************/
/***************************************************/



class Data{
private:
  void func(int);

public:
  void func(double);
};



#include <iostream>

using namespace std;

class Data{
private:
  void func(int);

public:
  void func(double);
};


int main()
{
    Data mydata;
    mydata.func(2.3); //gerceli
    mydata.func(5); //erişim yok

}

/***************************************************/
/***************************************************/


geçerli değil

class Data{
public:
  void func(double);
  void func(double);

};

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

//sınıf üye fonksiyonları storage ile alakası olmaz

class Data{
private:
    //int a, b;
private:
    void func(int);

private:
    void func(double);

};


int main()
{
   cout << "sizeof : " << sizeof (Data) << "\n";

}

/***************************************************/
/***************************************************/


#include <iostream>
#include "myclass.hpp"

using namespace std;


int main()
{
    Myclass m;

    m.foo(2);
    m.func(2, 5);

    fuu(m, 10);
}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;

//class resulotion -- isim arama

//.hpp
class Myclass{
    int mx, my;

public:
    void func();
    void foo();
};

//.cpp
void Myclass::func()
{
    if(1)
    {
        if(1)
        {
            //isim kullanmı olalım
            //ilk önce üye fonksiyon içinde aranır
            //bulamazsa class scope ta arar
            //bulamazsa globalda aranıyor
        }
    }
}


int main()
{

}

/***************************************************/
/***************************************************/

#include <iostream>

using namespace std;


//name resulotion

int x = 20;

int main()
{
    int x = 10;

    //C de bu :: operatoru yok. C++ da var ve global isme erişmemizi sağlar
    cout << "x : " << x << "\n";
    cout << "::x : " << ::x << "\n";
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
    int mx, my;
public:
    void func();
    void foo();
};

int mx = 123;

//.cpp
void Myclass::func()
{
    int mx = 10;

    Myclass::mx == 12; //class mx

    mx = 20; //yerel mx

    ++::mx; //global mx
}

int main()
{

}

/***************************************************/
/***************************************************/



#include <iostream>

using namespace std;

//.hpp
class Myclass{
    int mx, my;
public:
    void func();
    void foo();
};


//.cpp
void Myclass::func()
{
    mx = 12;
}

int main()
{
    Myclass m1, m2;

    //m1 adresi aslında gizliden fonksiyona gönderiliyor
    m1.func(); //mx m1'in dir
    //m2 adresi aslında gizliden fonksiyona gönderiliyor
    m2.func(); //mx m2'in dir
}

/***************************************************/
/***************************************************/


#include <iostream>

using namespace std;

//.hpp
class Myclass{
    int mx, my;
public:
    void func();
    void foo(int);
};

void foo()
{

}


//.cpp
void Myclass::func()
{
    //gecerlimi? gecerli ise hangisi cagrılır
    //class scope da isim arandı bulundu
    foo(); //sentask hatası parametre eşleçmediğiiçin


    //global foo cagırmak için çözünürlük operatorunu kullanmamız gerekli
    ::foo();
}




int main()
{

}

/***************************************************/
/***************************************************/





























